/*
 * The MIT License (MIT)
 *
 * Copyright (C) 2013 Dennis Möhlmann <mail@dennismoehlmann.de>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var path = require('path');
var fs = require('fs');
var SourceNode = require('source-map').SourceNode;
var LanguageParser = require('../language_parser');
var CaptureNode = LanguageParser.CaptureNode;
var Transform = require('../transform');
var util = require('../util');
var Set = util.Set;

module AdriaNode = proto (CaptureNode) {

    validIdentifier: {
        common: new Set([
            'arguments', 'this', 'true', 'false', 'null', 'undefined', 'Infinity', 'NaN',
            'Array', 'Boolean', 'Date', 'Intl', 'JSON', 'Function', 'Math', 'Number', 'Object', 'RegExp', 'String',
            'ArrayBuffer', 'DataView', 'Float32Array', 'Float64Array', 'Int16Array', 'Int32Array', 'Int8Array',
            'Uint16Array', 'Uint32Array', 'Uint8Array',
            'Error', 'EvalError', 'RangeError', 'ReferenceError', 'SyntaxError', 'TypeError', 'URIError',
            'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'eval',
            'setTimeout', 'clearTimeout', 'setInterval', 'clearInterval',
            'isFinite', 'isNaN', 'parseFloat', 'parseInt',
            'console', 'debugger',
            'application', 'Async',
        ]),
        node: new Set([ 'process' ]),
        web: new Set([ 'window', 'document', 'performance' ]),
    },

    /**
     * find this node's scope
     *
     * @return scope node
     */
    findScope: function() {
        return this.ancestor(null, 'scope|module');
    },

    /**
     * returns true if the name is defined in current scope or above
     *
     * @param string name
     */
    checkDefined: function(name) {

        // check base identifier

        if (this.validIdentifier.common.has(name) || this.validIdentifier.node.has(name)) { //!todo
            return;
        }

        // check scopes

        var scope = this;

        do {

            // first iteration might not be a scope

            if (scope instanceof Scope !== true) {
                continue;
            }

            // check locals, implicits and module exports

            if (scope.locals.has(name)) {
                return;
            }

            if (scope instanceof Scope && scope.implicits.has(name)) {
                return;
            }

            if (scope instanceof Module && (scope.exports.has(name) || scope.moduleExport === name)) {
                return;
            }

        } while ((scope = scope.findScope()) !== null);

        // check globally

        if (this.parser().transform.globals.has(name)) {
            return;
        }

        // check other parameter //!todo this allows all scope variables in parameters, not just other parameters

        var paramNode = this.ancestor(null, 'function_param_list');

        if (paramNode !== null) {

            var scope = paramNode.parent.get('body');
            scope.checkDefined(name);
            return;
        }

        throw new Error('Undefined variable "' + name + '" in ' + this.parser().file + ' line ' + this.row + ', column ' + this.col);

        return false;
    },

    addParentLookup: function(result, lookupName, ownName = lookupName) {

        // check if in a prototype, don't skip it if we are

        result.add('var __p, __p0 = __p = (this === this.constructor.prototype ? this : Object.getPrototypeOf(this));' + this.nl());

        // find self in protochain

        result.add('while (__p !== null && (__p.' + lookupName + ' !== ' + ownName + ' || __p.hasOwnProperty(\'' + lookupName + '\') === false)) {' + this.nl(1));
        result.add('__p = Object.getPrototypeOf(__p);' + this.nl(-1));
        result.add('}' + this.nl());

        // get parent prototype

        result.add('__p = (__p !== null ? Object.getPrototypeOf(__p).constructor : __p0);' + this.nl());
    },

    /**
     * find name on left side of assignment or proto body item
     *
     * @param mustBeMember only accept member names
     * @return SourceNode for name or null
     */
    findName: function() {

        var result = null;
        var nameNode = this.get('name');

        if (nameNode.isNode() === false) {

            nameNode = this.ancestor(null, 'module_statement|export_statement|expression|dec_def|proto_body_item');

            if (nameNode !== null) {

                //fetch from declaration, protoliteral item's left side or expression

                if (nameNode.value === 'dec_def' || nameNode.value === 'module_statement' || nameNode.value === 'export_statement') {

                    result = nameNode.get('name').toSourceNode();

                } else if (nameNode.value === 'proto_body_item') {

                    result = nameNode.get('key').toSourceNode();

                } else if (nameNode.value === 'expression') {

                    result = nameNode.findAssignee();
                }
            }

        } else {
            result = nameNode.toSourceNode();
        }

        return result;
    },

    /**
     * fetches the rightmost name on the left side of an assignment
     * i.e. name of (a || b).node.name
     *
     * @return SourceNode for name or null
     */
    findAssignee: function() {

        var children = this.children;
        var found = -1;
        var result = null;

        for (var id = 0; id < children.length; id++) {
            if (children[id].key === 'assignment_op') {
                found = id - 1;
                break;
            }
        }

        if (found !== -1) {

            var child = children[found];

            if (child.value === 'access_operation_member' || child.value === 'access_operation_proto') {
                result = child.csn(child.get('item').value);
            }

            if (child.key === 'ident') {
                result = child.csn(child.toSourceNode());
            }
        }

        return result;
    },

};

export AccessOperationProtocall = proto (AdriaNode) {

    toSourceNode: function() {

        var params = this.get('call');
        var result = this.csn();

        result.add([ '.prototype.', this.csn(this.get('item').value), '.call(this' ]);

        params.each(function(param) {
            result.add([ ', ', param.toSourceNode() ]);
        });

        result.add(')');

        return result;
    },
};

export ConstLiteral = proto (AdriaNode) {

    toSourceNode: function() {

        var stringNode = this.get('string');

        if (stringNode.isNode()) {
            return this.csn(stringNode.value);
        } else {
            return this.csn(this.get('numeric').value);
        }
    },
};

export Scope = proto (AdriaNode) {

    locals: null,
    implicits: null,

    constructor: function(key, value) {
        this.locals = new Set();
        this.implicits = new Set();
        AdriaNode->constructor(key, value);
    },

    toSourceNode: function() {

        // prefix content with local variable

        var content = AdriaNode->toSourceNode();
        var result = this.csn();

        if (this.locals.length > 0) {
            result.add([ 'var ', this.locals.toArray().join(', '), ';' + this.nl() ]);
        }

        result.add(content);

        return result;
    },
};

export Module = proto (Scope) {

    moduleExport: null,
    exports: null,

    constructor: function(key, value) {
        this.exports = new Set();
        Scope->constructor(key, value);
    },

    toSourceNode: function() {

        var parser = this.parser();

        this.nl(1);

        var code = Scope->toSourceNode();
        var exports = this.exports.toArray();
        var file = parser.file;

        var result = this.csn('module(\'' + parser.moduleName + '\', function(module, resource) {' + this.nl());

        // tweak: commonJS module.exports shortcut

        if (parser.transform.options['tweak-exports']) {
            result.add('var exports = module.exports;' + this.nl());
        }

        result.add(code);

        if (this.moduleExport !== null) {
            result.add('module.exports = ' + this.moduleExport + ';' + this.nl());
        }

        for (var id in exports) {
            result.add('module.exports.' + exports[id] + ' = ' + exports[id] + ';' + this.nl());
        }

        result.add(this.nl(-1) + '});' + this.nl());

        return result;
    },
};

export InvokeOperation = proto (AdriaNode) {

    toSourceNode: function() {

        var result = this.csn();
        result.add('(');
        this.params = [];

        this.each(function(node, first) {

            if (first === false) {
                result.add(', ');
            }

            result.add(node.toSourceNode());
        });

        result.add(')');

        return result;
    },
};

export AsyncWrapOperation = proto (AdriaNode) {

    params: null,

    toSourceNode: function() {

        var id = 0;
        var result = this.csn();
        this.params = [];
        result.add('(');

        this.each(function(node, first) {

            if (first === false) {
                result.add(', ');
            }

            if (node.value === '#') {
                result.add('___callback');
            } else {
                result.add('___' + id++);
                this.params.push(node.toSourceNode().toString());
            }
        });

        result.add(')');

        return result;
    },
};

export FunctionLiteral = proto (AdriaNode) {

    defaultArgs: null,
    name: null,
    lookupParent: false,

    constructor: function(key, value) {
        this.defaultArgs = [ ];
        AdriaNode->constructor(key, value);
    },

    toSourceNode: function() {

        // indent child content, compensate by not indenting at opening {

        this.nl(1);

        // construct result string

        var result = this.csn();
        result.add('function');

        if (this instanceof GeneratorLiteral || this instanceof AsyncLiteral) {
            result.add('*');
        }

        // name anonymous functions within their scope

        this.name = this.findName();

        if (this.name !== null) {

            this.get('body').implicits.add(this.name);
            result.add([ ' ', this.name ]);
        }

        // statements also add the name to the parent scope

        if (this instanceof FunctionStatement || this instanceof GeneratorStatement) {
            this.findScope().implicits.add(this.name);
        }

        result.add('(');
        result.add(this.get('param_list').toSourceNode());
        result.add(') {' + this.nl());

        for (var id in this.defaultArgs) {
            result.add([ this.defaultArgs[id], ';' + this.nl() ]);
        }

        var body = this.get('body').toSourceNode();

        // prepare parent lookup, if parent keyword is used in body

        if (this.lookupParent) {
            this.addParentLookup(result, this.name);
        }

        result.add([ body, this.nl(-1) + '}' ]);

        return result;
    },
};

export GeneratorLiteral = proto (FunctionLiteral) { };
export FunctionStatement = proto (FunctionLiteral) { };
export GeneratorStatement = proto (GeneratorLiteral) { };

export AsyncLiteral = proto (FunctionLiteral) {

    toSourceNode: function() {

        // include Async module

        var parser = this.parser();
        parser.resultData.globals.add('___Async');
        parser.transform.usedBuiltins.add('async.adria');

        var result = this.csn();
        result.add('(function() {' + this.nl(1));
        result.add([ 'var ___self = ', FunctionLiteral->toSourceNode(), ';', this.nl() ]);
        result.add([ 'return function(', this.get('param_list').toSourceNode(), ') {' + this.nl(1) ]);
        result.add('return new ___Async(___self.apply(this, arguments));' + this.nl(-1));
        result.add('};'+ this.nl(-1));
        result.add('})()');
        return result;
    },
};

export AsyncStatement = proto (AsyncLiteral) { };

export FunctionParamList = proto (AdriaNode) {

    toSourceNode: function() {

        var name, defaultArg, valueNode;
        var result = this.csn();
        var functionNode = this.ancestor('function|generator|async');
        var scope = functionNode.get('body');

        this.eachKey('item', function(node) {

            name = node.get('name').toSourceNode();

            result.add(name);
            scope.implicits.add(name);

            // check for default args, push those to FunctionLiteral's defaultArgs property

            valueNode = node.get('value');

            if (valueNode.isNode()) {

                defaultArg = new SourceNode();
                defaultArg.add([ name, ' = (', name, ' !== undefined ? ', name, ' : (', valueNode.toSourceNode(), '))' ]);
                functionNode.defaultArgs.push(defaultArg);
            }
        });

        return result.join(', ');
    },
};

export BaseLiteral = proto (AdriaNode) {

    scan: function(state) {

        AdriaNode->scan(state);

        this.eachKey('ident', function(child) {
            this.checkDefined(child.value);
        });
    },

    toSourceNode: function() {

        var result = '';

        this.each(function(child) {
            switch (child.key) {
                //!case 'ident':
                case 'numeric':
                case 'string':
                case 'regexp':
                case 'brace':
                    result += this.csn(child.value);
                    break;

                default:
                    result += child.toSourceNode();
            }
        });

        return result;
    },
};

export DoWhileStatement = proto (AdriaNode) {

    toSourceNode: function() {

        var result = this.csn();
        result.add('do {' + this.nl(1));
        result.add(this.get('body').toSourceNode());
        result.add(this.nl(-1) + '}');
        result.add([ ' while (', this.get('condition').toSourceNode(), ');' ]);

        return result;
    },
};

export WhileStatement = proto (AdriaNode) {

    toSourceNode: function() {

        var result = this.csn();
        result.add([ 'while (', this.get('condition').toSourceNode(), ') {' + this.nl(1) ]);
        result.add(this.get('body').toSourceNode());
        result.add(this.nl(-1) + '}');

        return result;
    },
};

export IfStatement = proto (AdriaNode) {

    toSourceNode: function() {

        var result = this.csn();
        result.add([ 'if (', this.get('condition').toSourceNode(), ') {' + this.nl(1) ]);
        result.add([ this.get('if_body').toSourceNode(), this.nl(-1) + '}' ]);

        var elseIf = this.get('else_if');

        if (elseIf.isNode()) {

            result.add([' else ', elseIf.toSourceNode() ]);

        } else {

            var elseBody = this.get('else_body');

            if (elseBody.isNode()) {
                result.add([ ' else {' + this.nl(1), elseBody.toSourceNode(), this.nl(-1) + '}' ]);
            }
        }

        return result;
    },
};

export SwitchStatement = proto (AdriaNode) {

    toSourceNode: function() {

        var result = this.csn();
        result.add([ 'switch (', this.get('value').toSourceNode(), ') {', this.nl(1) ]);

        // cases

        this.eachKey('case', function(caseNode) {

            result.add(['case ', caseNode.get('match').toSourceNode(), ':' + this.nl(1) ]);
            result.add(caseNode.get('body').toSourceNode());
            result.add(this.nl(-1));
        });

        // default case

        var defaultNode = this.get('default');

        if (defaultNode.isNode()) {
            result.add('default:' + this.nl(1));
            result.add(defaultNode.get('body').toSourceNode());
            result.add(this.nl(-1));
        }

        result.add(this.nl(-1) + '}');

        return result;
    },
};

export ForCountStatement = proto (AdriaNode) {

    toSourceNode: function() {

        var initNode = this.get('init');
        var init;

        if (initNode.value === 'var_def') {

            var varDefs = this.csn();

            initNode.eachKey('item', function(node) {

                var valueNode = node.get('value');
                var nameNode = node.get('name');

                this.findScope().locals.add(nameNode.value);

                if (valueNode.isNode()) {
                    var varDef = new SourceNode();
                    varDef.add([ nameNode.toSourceNode(), ' = ', valueNode.toSourceNode() ]);
                    varDefs.add(varDef);
                } else {
                    varDefs.add(nameNode.toSourceNode);
                }
            });

            init = new SourceNode();
            init.add([ varDefs.join(', ') ]);

        } else {

            init = initNode.toSourceNode();
        }

        var test = this.get('test').toSourceNode();
        var condOp = this.get('cond_op').toSourceNode();

        var result = this.csn();
        result.add([ 'for (', init, '; ', test, ';', condOp, ') {' + this.nl(1) ]);
        result.add(this.get('body').toSourceNode());
        result.add(this.nl(-1) + '}');

        return result;
    },
};

export ForInStatement = proto (AdriaNode) {

    toSourceNode: function() {

        var keyNode = this.get('key');
        var valueNode = this.get('value');

        if (this.get('var').isNode()) {

            var locals = this.findScope().locals;
            locals.add(keyNode.value);

            if (valueNode.isNode()) {
                locals.add(valueNode.value);
            }
        }

        var source = this.get('source').toSourceNode();
        var key = keyNode.toSourceNode();

        var result = this.csn();
        result.add('for (');
        result.add(key);
        result.add(' in ');
        result.add(source);
        result.add(') {' + this.nl(1));

        if (valueNode.isNode()) {
            result.add([ valueNode.toSourceNode(), ' = ', source, '[', key, '];', this.nl() ]);
        }

        result.add([ this.get('body').toSourceNode(), this.nl(-1), '}' ]);

        return result;
    },
};

export ObjectLiteral = proto (AdriaNode) {

    toSourceNode: function() {

        var items = new SourceNode();

        // indent now, so that children will be indented. correct for this by not indenting during return

        this.nl(1);

        this.each(function(child) {
            var item = new SourceNode();
            item.add(child.get('key').csn(child.get('key').value));
            item.add(': ');
            item.add(child.get('value').toSourceNode());
            items.add(item);
        });

        var result =  this.csn();

        if (items.toString().length >= 60) {

            result.add('{' + this.nl());
            result.add(items.join(',' + this.nl()));
            result.add(this.nl() + this.nl(-1) + '}');

        } else {

            this.nl(-1);
            result.add('{ ');
            result.add(items.join(', '));
            result.add(' }');
        }

        return result;
    }
};

export ProtoBodyProperty = ObjectLiteral;

export ArrayLiteral = proto (AdriaNode) {

    toSourceNode: function() {

        var items = new SourceNode();

        // indent now, so that children will be indented. correct for this by not indenting during return

        this.nl(1);

        this.each(function(child) {
            items.add(child.toSourceNode());
        });

        var result = this.csn();

        if (items.toString().length >= 60) {

            result.add('[' + this.nl());
            result.add(items.join(',' + this.nl()));
            result.add(this.nl() + this.nl(-1) + ']');

        } else {

            this.nl(-1);
            result.add('[ ');
            result.add(items.join(', '));
            result.add(' ]');
        }

        return result;
    },
};

export Expression = proto (AdriaNode) {

    wrapPrefix: new Set([
        'member', 'index', 'proto',
        'call', 'pcall', 'item'
    ]),

    preprocess: function(state) {

        AdriaNode->preprocess(state);

        // restructure async wraps

        var children = this.children;
        var id = children.length;
        var end = -1;

        while (id--) {
            if (children[id].key === 'wrap') {
                end = id;
            } else if (end > -1 && this.wrapPrefix.lacks(children[id].key)) {
                this.nest(id + 1, end);
                end = -1;
            } else if (end > -1 && end < children.length -1 && id === 0) {
                this.nest(0, end);
            }
        }
    },

    scan: function(state) {

        AdriaNode->scan(state);

        this.eachKey('ident', function(child) {
            this.checkDefined(child.value);
        });
    },

    toSourceNode: function() {

        var children = this.children;
        var propertyAssignSplit = -1;
        var wrapper = this.get('wrap');
        var result = this.csn();

        //this instanceof AsyncLiteral

        for (var id, child in children) {

            if (children[+id+1] !== undefined && children[+id+1].key === 'passignment_op') {
                propertyAssignSplit = +id + 1;
                break;
            }

            switch (child.key) {
                case 'member':
                    result.add(child.csn('.' + child.children[0].value));
                    break;
                case 'index':
                    result.add(child.csn('['));
                    result.add(child.toSourceNode());
                    result.add(child.csn(']'));
                    break;
                case 'proto':
                    result.add(child.csn('.prototype.' + child.children[0].value));
                    break;
                case 'call':
                case 'pcall':
                case 'wrap':
                case 'ident':
                    result.add(child.csn(child.toSourceNode()));
                    break;
                case 'brace_op':
                case 'xfix_op':
                    result.add(child.csn(child.value));
                    break;
                case 'unary_op':
                    result.add(child.csn(child.value.search(/[a-z]/) > -1 ? child.value + ' ' : child.value));
                    break;
                case 'binary_op':
                case 'assignment_op':
                case 'ternary_op':
                    result.add([ ' ', child.csn(child.value), ' ' ]);
                    break;
                default:
                    result.add(child.toSourceNode());
                    break;
            }
        }

        if (propertyAssignSplit > -1) {

            result.prepend('Object.defineProperty(');
            child = children[propertyAssignSplit - 1];

            switch (child.key) {
                case 'member':
                    result.add(", '" + child.children[0].value + "',");
                    break;
                case 'index':
                    result.add(', ');
                    result.add(child.toSourceNode());
                    result.add(', ');
                    break;
                case 'proto':
                    result.add(".prototype, '" + child.children[0].value + "', ");
                    break;
            }

            if (children[propertyAssignSplit].value === ':=') {
                result.add('{' + this.nl(1) + 'value: ');
                result.add(children[propertyAssignSplit + 1].toSourceNode());
                result.add(',' + this.nl() + 'writable: false' + this.nl(-1) + '})');
            } else {
                result.add(children[propertyAssignSplit + 1].toSourceNode());
                result.add(')');
            }
        }

        // async wrap operation

        if (wrapper.isNode()) {

            var locals = '';
            var params = wrapper.params.join(', ');

            for (var id = 0; id < wrapper.params.length; id++) {
                locals += '___' + id + ', ';
            }

            result = this.csn([
                '(function(' + locals + '___callback) {', this.nl(1),
                'try { return ', result, '; } catch (___exc) { ___callback(___exc); }', this.nl(-1),
                '}).bind(this' + (wrapper.params.length > 0 ? ', ' + params : '') + ')'
            ]);
        }

        return result;
    }
};

export ProtoLiteral = proto (AdriaNode) {

    constructorArgs: null,
    constructorBody: null,
    constructorDefaults: null,
    lookupParent: false,
    name: '',

    constructor: function(key, value) {

        this.constructorArgs = [ ];
        this.constructorDefaults = [ ];
        AdriaNode->constructor(key, value);
    },

    toSourceNode: function() {

        // get own and parent name

        var nameSN = this.findName();

        if (nameSN !== null) {
            this.name = nameSN.toString();
        }

        var parentNode = this.get('parent');
        var haveParent = parentNode.isNode();

        // generate output

        var assignTo = '';

        if (this.value === 'proto_statement') {

            // statement requires assignment of wrapper

            var locals = this.findScope().locals;
            locals.add(this.name);
            assignTo = this.name + ' = ';
        }

        var result = this.csn(assignTo + '(function(' + (haveParent ? '___parent' : '') + ') {' + this.nl(1));
        var body = this.get('body').toSourceNode();

        // user- or default-constructor

        if (this.constructorBody !== null) {

            result.add('var ___self = function ' + this.name + '(');
            result.add(this.constructorArgs);
            result.add(') {' + this.nl(1));

            for (var id in this.constructorDefaults) {
                result.add(this.constructorDefaults[id]);
                result.add(';' + this.nl());
            }

            // dynamic parent lookup

            if (this.lookupParent) {
                this.addParentLookup(result, 'constructor', '___self');
            }

            result.add(this.constructorBody);
            result.add(this.nl(-1) + '};' + this.nl() + this.nl());

        } else {

            result.add('var ___self = function ' + this.name + '() {');

            if (haveParent) {
                result.add(this.nl(1) + '___parent.apply(this, arguments);' + this.nl(-1));
            }

            result.add('}' + this.nl() + this.nl());
        }

        // chain to parent

        if (haveParent) {
            result.add('___self.prototype = Object.create(___parent.prototype);' + this.nl());
            result.add('___self.prototype.constructor = ___self;' + this.nl() + this.nl());
        }

        // body elements

        result.add(body);

        // close and return

        result.add(this.nl() + 'return ___self;' + this.nl(-1));
        result.add('})(');
        result.add(parentNode.toSourceNode());
        result.add(')');

        if (this.value === 'proto_statement') {
            result.add(';');
        }

        return result;
    },
};

export ProtoStatement = ProtoLiteral;

export NewProtoLiteral = proto (ProtoLiteral) {

    toSourceNode: function() {

        var result = this.csn();
        result.add('new (');
        result.add(parent->toSourceNode());
        result.add(')(');

        var paramList = this.get('param_list');

        if (paramList.isNode()) {
            result.add(paramList.toSourceNode());
        }

        result.add(')');

        return result;
    }
};

export ProtoBodyItem = proto (AdriaNode) {

    toSourceNode: function()  {

        var protoNode = this.ancestor(null, 'new_proto_literal|proto_literal|proto_statement');
        //!var constructorName = protoNode.name;
        var keyNode = this.get('key');

        // set constructor attributes in ProtoLiteral, do the rest ourselves

        if (keyNode.value === 'constructor') {

            var functionNode = this.path('value.function');
            this.nl(1);
            protoNode.constructorArgs = functionNode.get('param_list').toSourceNode();
            protoNode.constructorDefaults = functionNode.defaultArgs;
            protoNode.constructorBody = functionNode.get('body').toSourceNode();
            protoNode.lookupParent = functionNode.lookupParent;
            this.nl(-1);
            return this.csn();

        } else {

            var valueNode = this.get('value');
            var result;

            if  (valueNode.value === 'proto_body_property') {

                var name = (keyNode.value === 'string' ? keyNode.value : '"' + keyNode.value + '"');

                result = this.csn('Object.defineProperty(___self.prototype, ' + name + ', ');
                result.add(valueNode.toSourceNode());
                result.add(');' + this.nl());
                return result;

            } else {

                var name = (keyNode.value === 'string' ? '[' + keyNode.value + ']' : '.' + keyNode.value);

                result = this.csn('___self.prototype' + name + ' = ');
                result.add(valueNode.toSourceNode());
                result.add(';' + this.nl());
                return result;
            }
        }
    }
};

export ReturnStatement = proto (AdriaNode) {

    toSourceNode: function() {

        var result = this.csn();
        var type = this.get('type');

        result.add([ type.csn(type.value), ' ' ]);
        result.add(this.get('value').toSourceNode());
        result.add(';' + this.nl());

        return result;
    },
};

export FlowStatement = ReturnStatement;

export YieldLiteral = proto (AdriaNode) {

    toSourceNode: function() {

        var result = this.csn();
        var type = this.get('type');

        result.add([ type.csn(type.value), ' ' ]);
        result.add(this.get('value').toSourceNode());

        return result;
    },
};

var catchSpecificsId = 1;

export CatchSpecifics = proto (AdriaNode) {

    toSourceNode: function() {

        var name = '___exc' + (catchSpecificsId++);

        var result = this.csn();
        result.add(' catch (' + name + ') {' + this.nl(1));

        // specifics

        this.eachKey('specific', function(node, first, last) {

            if (first !== true) {
                result.add(' else ');
            }

            var valueNode = node.get('value');
            this.findScope().locals.add(valueNode.value);

            result.add('if (' + name + ' instanceof ');
            result.add(node.get('type').toSourceNode());
            result.add(') {' + this.nl(1));
            result.add(valueNode.value + ' = ' + name + ';' + this.nl());
            result.add(node.get('body').toSourceNode());
            result.add(this.nl(-1) + '}');
        });

        // optional all catch

        var allNode = this.get('catch');

        if (allNode.isNode()) {

            var valueNode = allNode.get('value');
            this.findScope().locals.add(valueNode.value);

            result.add(' else { ' + this.nl(1));
            result.add(valueNode.value + ' = ' + name + ';' + this.nl());
            result.add(allNode.get('body').toSourceNode());
            result.add(this.nl(-1) + '}');

        } else {

            result.add(' else { ' + this.nl(1));
            result.add('throw ' + name + ';' + this.nl());
            result.add(this.nl(-1) + '}');
        }

        result.add(this.nl(-1) + '}');

        return result;
    },
};


export CatchAll = proto (AdriaNode) {

    toSourceNode: function() {

        var result = this.csn();
        var valueNode = this.get('value');

        this.findScope().implicits.add(valueNode.value);

        result.add(' catch (');
        result.add(valueNode.toSourceNode());
        result.add(') {' + this.nl(1));
        result.add(this.get('body').toSourceNode());
        result.add(this.nl(-1) + '}');

        return result;
    },
};

export TryCatchFinallyStatement = proto (AdriaNode) {

    toSourceNode: function() {

        var result = this.csn();

        result.add('try {' + this.nl(1));
        result.add(this.get('body').toSourceNode());
        result.add(this.nl(-1) + '}');

        var allNode = this.get('all');

        if (allNode.isNode()) {
            result.add(allNode.toSourceNode());
        } else {
            result.add(this.get('specifics').toSourceNode());
        }

        var finallyNode = this.get('finally');

        if (finallyNode.isNode()) {
            result.add('finally {' + this.nl(1));
            result.add(finallyNode.toSourceNode());
            result.add(this.nl(-1) + '}');
        }

        return result;
    },
};

export ThrowStatement = proto (AdriaNode) {

    toSourceNode: function() {

        var result = this.csn('throw ');
        result.add(this.get('exception').toSourceNode());
        result.add(';' + this.nl());

        return result;
    },
};

export AssertStatement = proto (AdriaNode) {

    toSourceNode: function() {

        var result = this.csn();

        if (this.parser().transform.options.assert) {
            result.add('assert(');
            result.add(AdriaNode->toSourceNode());
            result.add(');' + this.nl());
        }

        return result;
    }
};

export Statement = proto (AdriaNode) {

    toSourceNode: function() {

        var type = this.children[0].key;
        var result = this.csn();

        result.add(AdriaNode->toSourceNode());

        switch (type) {
            case 'expression':
                result.add(';' + this.nl());
                break;

            default:
                result.add(this.nl());
        }

        return result;
    },
};

export InterruptibleStatement = Statement;

var AdriaFileNode = proto (AdriaNode) {

    /**
     * relative nodejs paths have to be prefixed with ./ or ../
     *
     * @param filename
     * @param boolean true if path is a relative nodejs path
     */
    isRelativePath: function(filename) {
        return filename.slice(0, 2) === './' || filename.slice(0, 3) === '../';
    },

    makeBaseRelative: function(filename, parser) {

        var absName = path.dirname(parser.file) + '/' + filename;
        return path.relative(parser.transform.options.basePath, absName);
    },

    resolvePath: function(fileName, parser) {

        var options = parser.transform.options;
        var relname;

        if (this.isRelativePath(fileName)) {

            // check project base

            relname = this.makeBaseRelative(fileName, parser);

            if (fs.existsSync(options.basePath + relname)) {
                return path.normalize(relname);
            }

        } else {

            // try paths

            for (var id in options.paths) {

                relname = options.paths[id] + fileName;

                if (fs.existsSync(options.basePath + relname)) {
                    return path.normalize(relname);
                }
            }
        }

        return null;
    },
};

export ResourceLiteral = proto (AdriaFileNode) {

    toSourceNode: function() {

        var parser = this.parser();
        var options = parser.transform.options;
        var fileNode = this.get('file');
        var fileName = fileNode.toSourceNode().toString().slice(1, -1);

        var resolvedName = this.resolvePath(fileName, parser);

        if (resolvedName !== null) {
            parser.resultData.resources.add(resolvedName);
        } else {
            throw new Error('Could not find resource ' + fileName + ' (required by ' + parser.file + ')');
        }

        var result = this.csn();
        result.add('resource(');
        result.add(fileNode.csn("'" + resolvedName + "'"));
        result.add(')');
        return result;
    },
};

export RequireLiteral = proto (AdriaFileNode) {

    toSourceNode: function() {

        var parser = this.parser();
        var options = parser.transform.options;
        var fileNode = this.get('file');
        var moduleName = fileNode.toSourceNode().toString().slice(1, -1);
        var result = this.csn();
        var requireFunction = 'require';
        var resolvedName;

        // check builtins

        resolvedName = util.normalizeExtension(moduleName, options.fileExt);

        if (parser.transform.builtins[resolvedName] !== undefined) {

            // module is builtin, set flag for inclusion by transform

            parser.transform.usedBuiltins.add(resolvedName);

        } else {

            // check if the require is an Adria module and needs to be included

            resolvedName = this.resolvePath(util.normalizeExtension(moduleName, options.fileExt), parser);

            if (resolvedName !== null) {

                moduleName = resolvedName;
                parser.resultData.requires.add(moduleName);

                if (options.platform === 'node') {
                    requireFunction = '__require';
                }

            } else if (options.platform !== 'node' || moduleName.hasPostfix(options.fileExt)) {

                throw new Error('Could not find module ' + moduleName + ' (required by ' + parser.file + ')');
            }
        }

        result.add(requireFunction + '(');
        result.add(fileNode.csn("'" + moduleName + "'"));
        result.add(')');
        return result;
    },
};

export ModuleStatement = proto (AdriaNode) {

    toSourceNode: function() {

        var name = this.get('name').value;
        var moduleNode = this.ancestor(null, 'module');
        moduleNode.moduleExport = name;
        moduleNode.locals.add(name);

        var result = this.csn();
        result.add(name);
        result.add(' = ');
        result.add(this.get('value').toSourceNode());
        result.add(';' + this.nl());
        return result;
    },
};

export ExportStatement = proto (AdriaNode) {

    toSourceNode: function() {

        var name = this.get('name').value;
        var moduleNode = this.ancestor(null, 'module');
        moduleNode.exports.add(name);
        moduleNode.locals.add(name);

        var result = this.csn();
        result.add(name);
        result.add(' = ');
        result.add(this.get('value').toSourceNode());
        result.add(';' + this.nl());
        return result;
    },
};

export GlobalDef = proto (AdriaNode) {

    toSourceNode: function() {

        var valueNode, nameNode;
        var globals = this.parser().resultData.globals;
        var result = this.csn();
        var nl = this.nl();

        this.eachKey('item', function(node) {
            nameNode = node.get('name');
            valueNode = node.get('value');

            globals.add(nameNode.value);

            if (valueNode.isNode()) {
                result.add(nameNode.value + ' = ');
                result.add(valueNode.toSourceNode());
                result.add(';' + nl);
            }
        });

        return result;
    },
};

export ParentLiteral = proto (AdriaNode) {

    toSourceNode: function() {
        this.ancestor('function').lookupParent = true;
        return this.csn('__p');
    }
};

export Ident = proto (AdriaNode) {

    toSourceNode: function() {
        return this.csn(this.value);
    }
};

export Name = Ident;

export VarDef = proto (AdriaNode) {

    toSourceNode: function() {

        var valueNode, nameNode;
        var locals = this.findScope().locals;
        var result = this.csn();
        var nl = this.nl();

        this.eachKey('item', function(node) {
            nameNode = node.get('name');
            valueNode = node.get('value');

            locals.add(nameNode.value);

            if (valueNode.isNode()) {
                result.add(nameNode.value + ' = ');
                result.add(valueNode.toSourceNode());
                result.add(';' + nl);
            }
        });

        return result;
    },
};

export ImportStatement = proto (AdriaNode) {

    toSourceNode: function() {

        var implicits = this.findScope().implicits;

        this.eachKey('item', function(node) {
            implicits.add(node.value);
        });

        return this.csn();
    },
};
