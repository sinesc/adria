/*
 * Adria transcompiler
 *
 * Copyright (C) 2014 Dennis MÃ¶hlmann <mail@dennismoehlmann.de>
 * Licensed under the MIT license.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var path = require('path');
var fs = require('fs');
var Set = require('astd/set');
var Map = require('astd/map');
var SourceNode = require('source-map').SourceNode;  //!todo remove dep from here
var util = require('../util');
var LanguageParser = require('../language_parser');
var CaptureNode = LanguageParser.CaptureNode;
var ASTException = require('../language_parser/ast_exception');

//!todo this needs various refactoring
// - tool methods should not return SourceNodes but AdriaNodes (consistency)
// - all nodes, including String, Ident, ... should have a toSourceNode method to avoid specialcases where node.value needs to be used
// - need to parse property name strings instead of copying verbatim: unescape the js string, check if valid for .property syntax, otherwise use ['property'] syntax
// - sourcemapping is dysfunctional: needs wrapper, needs proper newline handling
// - various nodes do too much stuff that their children should handle, i.e. ProtoBodyItem

module AdriaNode = proto (CaptureNode) {

    /**
     * find this node's scope
     *
     * @param boolean fromParent default false, if true start looking at parent instead of this
     * @return scope node/null
     */
    findScope: func(fromParent = false) {
        return this.findProto(Scope, fromParent, null);
    },

    /**
     * returns true if the name is defined in current scope or above
     *
     * @param string name
     */
    checkDefined: func(name) {

        var parser = this.parser();

        if (parser.transform.implicits.has(name) || parser.transform.globals.has(name)) {
            return;
        }

        if (this.findScope().findRef(name) !== null) {
            return;
        }

        throw new ASTException('Undefined reference "' + name + '"', this);
    },

    /**
     * adds dynamic parent lookup code to given source-node
     *
     * @param result SourceNode
     * @param lookupName name of function to look up
     * @param ownName name of function containing the lookup
     */
    addParentLookup: func(result, lookupName, ownName = lookupName) {

        // check if in a prototype, don't skip it if we are

        result.add('var ___p, ___p0 = ___p = (this === this.constructor.prototype ? this : Object.getPrototypeOf(this));' + this.nl());

        // find self in proto-chain

        result.add('while (___p !== null && (___p.' + lookupName + ' !== ' + ownName + ' || ___p.hasOwnProperty(\'' + lookupName + '\') === false)) {' + this.nl(1));
        result.add('___p = Object.getPrototypeOf(___p);' + this.nl(-1));
        result.add('}' + this.nl());

        // get parent prototype

        result.add('___p = (___p !== null ? Object.getPrototypeOf(___p).constructor : ___p0);' + this.nl());
    },

    /**
     * find name on left side of assignment or proto body item
     *
     * @return SourceNode for name or null
     */
    findName: func() {

        var result = null;
        var nameNode = this.get('name');

        if (nameNode.isNode() === false) {

            nameNode = this.ancestor(null, ['module_statement', 'export_statement', 'expression', 'dec_def', 'proto_body_item']);

            if (nameNode.isNode()) {

                // fetch from declaration, protoliteral item's left side or expression

                if (nameNode.value === 'dec_def' || nameNode.value === 'module_statement' || nameNode.value === 'export_statement') {

                    result = nameNode.get('name').toSourceNode();

                } else if (nameNode.value === 'proto_body_item') {

                    result = nameNode.get('key').toSourceNode();

                } else if (nameNode.value === 'expression') {

                    result = nameNode.findAssignee();
                }
            }

        } else {
            result = nameNode.toSourceNode();
        }

        return result;
    },

    /**
     * fetches the rightmost name on the left side of an assignment
     * i.e. name of (a || b).node.name
     *
     * @return SourceNode for name or null
     */
    findAssignee: func() {

        var children = this.children;
        var found = -1;
        var result = null;

        for (var id = 0; id < children.length; id++) {
            if (children[id].key === 'assignment_op') {
                found = id - 1;
                break;
            }
        }

        if (found !== -1) {

            var child = children[found];

            if (child.value === 'access_operation_member' || child.value === 'access_operation_proto') {
                result = child.csn(child.get('item').value);
            }

            if (child.key === 'ident') {
                result = child.csn(child.toSourceNode());
            }
        }

        return result;
    },

};

export AccessOperationProtocall = proto (AdriaNode) {

    toSourceNode: func() {

        var params = this.get('call');
        var result = this.csn();

        result.add([ '.prototype.', this.csn(this.get('item').value), '.call(this' ]);

        params.each(func(param) {
            result.add([ ', ', param.toSourceNode() ]);
        });

        result.add(')');

        return result;
    },
};

export ConstLiteral = proto (AdriaNode) {

    toSourceNode: func() {

        var stringNode = this.get('string');

        if (stringNode.isNode()) {
            return this.csn(stringNode.value);
        } else {
            return this.csn(this.get('numeric').value);
        }
    },
};

(func() {

    var scopeLocalId = 1;

    var findRefScope = func(name) {

        var scope = this;

        do {
            if (scope.getOwnRef(name) !== null) {
                return scope;
            }
        } while ((scope = scope.findScope(true)) !== null);

        return scope;
    };

    var createLocalName = func(name) {

        var scope = findRefScope.call(this, name);

        if (scope !== null) {
            return '___' + name + '_scp' + scopeLocalId++;
        }

        return name;
    };

    export Scope = proto (AdriaNode) {

        locals      : null,
        implicits   : null,

        constructor: func(key, value) {
            this.locals = new Map();
            this.implicits = new Map();
            AdriaNode->constructor(key, value);
        },

        addLocal: func(name) {

            if (this.getOwnRef(name)) {
                throw new ASTException('Reference "' + name + '" already defined in local scope', this);
            }

            var localName = createLocalName.call(this, name);
            this.locals.set(name, localName);
            return localName;
        },

        addImplicit: func(name, ignore = false) {

            // implicits may not be defined in any parent scope

            if (ignore == false && (this.getOwnRef(name) || findRefScope.call(this, name) !== null)) {
                throw new ASTException('Reference "' + name + '" already defined in local scope', this);
            }

            this.implicits.set(name, name);
            return name;
        },

        getOwnRef: func(name) {

            assert(this.locals instanceof Map);
            assert(this.implicits instanceof Map);

            if (this.locals.has(name)) {
                return this.locals.get(name);
            } else if (this.implicits.has(name)) {
                return this.implicits.get(name);
            }

            return null;
        },

        findRef: func(name) {

            var scope, refName;

            if ((refName = this.getOwnRef(name)) !== null) {
                return refName;
            } else if ((scope = findRefScope.call(this, name)) !== null) {
                if ((refName = scope.getOwnRef(name)) !== null) {
                    return refName;
                } else {
                    assert(true, 'scope claimed to have local but did not');
                }
            }

            return null;
        },

        refsToSourceNode: func() {

            if (this.locals.empty) {
                return this.csn();
            } else {
                return this.csn([ 'var ', this.locals.values().join(', '), ';' + this.nl() ]);
            }
        },
    };

})();

export Module = proto (Scope) {

    moduleExport: null,
    exports: null,

    constructor: func(key, value) {
        this.exports = new Map();
        Scope->constructor(key, value);
    },

    setModuleExport: func(name) {

        if (this.getOwnRef(name)) {
            throw new ASTException('Reference "' + name + '" already defined in local scope', this);
        }

        var localName = this.addLocal(name);
        this.moduleExport = localName;
        return name;
    },

    addExport: func(name) {

        if (this.getOwnRef(name)) {
            throw new ASTException('Reference "' + name + '" already defined in local scope', this);
        }

        var localName = this.addLocal(name);
        this.exports.set(name, localName);
        return name;
    },

    getOwnRef: func(name) {

        var refName;

        if ((refName = Scope->getOwnRef(name)) !== null) {
            return refName;
        }

        assert(this.exports instanceof Map);

        if (this.exports.has(name)) {
            return this.exports.get(name);
        } else if (this.moduleExport === name) {
            return this.moduleExport;
        }

        return null;
    },

    toSourceNode: func() {

        this.nl(1);

        var parser = this.parser();
        var code = Scope->toSourceNode();
        var file = parser.file;

        var result = this.csn('module(\'' + parser.moduleName + '\', function(module, resource) {' + this.nl());

        // tweak: commonJS module.exports shortcut

        if (parser.transform.options['tweak-exports']) {
            result.add('var exports = module.exports;' + this.nl());
        }

        result.add(this.refsToSourceNode());
        result.add(code);

        // module export

        if (this.moduleExport !== null) {
            result.add('module.exports = ' + this.moduleExport + ';' + this.nl());
        }

        // individual exports

        var exports = this.exports.keys();

        for (var id in exports) {
            result.add('module.exports.' + exports[id] + ' = ' + this.exports.get(exports[id]) + ';' + this.nl());
        }

        result.add(this.nl(-1) + '});' + this.nl());

        return result;
    },
};

export InvokeOperation = proto (AdriaNode) {

    toSourceNode: func(includeBraces = true) {

        var result = this.csn();

        if (includeBraces) {
            result.add('(');
        }

        this.each(func(node, first) {

            if (first === false) {
                result.add(', ');
            }

            result.add(node.toSourceNode());
        });

        if (includeBraces) {
            result.add(')');
        }

        return result;
    },
};

/**
 * handles an async-wrap-operation. note: wrapping happens in Expression, this
 * is just the operation where "(..., #)" is the operator.
 */
export AsyncWrapOperation = proto (AdriaNode) {

    params: null,

    toSourceNode: func() {

        var id = 0;
        var result = this.csn();
        this.params = [];
        result.add('(');

        this.each(func(node, first) {

            if (first === false) {
                result.add(', ');
            }

            if (node.value === '#') {
                result.add('___callback');
            } else {
                result.add('___' + id++);
                this.params.push(node.toSourceNode().toString());
            }
        });

        result.add(')');

        return result;
    },
};

(func() {
    var thisId = 1;

    export FunctionLiteral = proto (Scope) {

        defaultArgs     : null,
        name            : null, //!todo seems to be a sourcenode!
        lookupParent    : false,
        thisId          : 0,

        constructor: func(key, value) {
            this.defaultArgs = [ ];
            Scope->constructor(key, value);
        },

        storeContext: func() {

            if (this.thisId === 0) {
                this.thisId = thisId++;
            }

            return '___ths' + this.thisId;
        },

        toSourceNode: func() {

            // indent child content, compensate by not indenting at opening {

            this.nl(1);

            // construct result string

            var result = this.csn();
            result.add('function');

            if (this instanceof GeneratorLiteral || this instanceof AsyncLiteral) {
                result.add('*');
            }

            // name anonymous functions within their scope, don't name async functions as any recursion attempts need to refer to the outer function

            var nameSN = this.findName();

            if (nameSN !== null && nameSN.toString().match(/^([\'\"]).*\1$/) === null) {
                this.name = nameSN;
            } else {
                this.name = null;
            }

            if (this.name !== null && this instanceof AsyncLiteral === false) {

                this.addImplicit(this.name.toString(), true);
                result.add([ ' ', this.name ]);
            }

            // statements also add the name to the parent scope

            if (this instanceof FunctionStatement || this instanceof GeneratorStatement || this instanceof AsyncStatement) {
                this.parent.findScope().addImplicit(this.name.toString());
            }

            // handle parameters and default arguments

            result.add([ '(', this.get('param_list').toSourceNode(), ') {' + this.nl() ]);

            for (var id in this.defaultArgs) {
                result.add([ this.defaultArgs[id], ';' + this.nl() ]);
            }

            var body = this.get('body').toSourceNode();

            // local variables and stored this context

            result.add(this.refsToSourceNode());

            if (this.thisId > 0) {
                result.add('var '  + this.storeContext() + ' = this;' + this.nl());
            }

            // prepare parent lookup, if parent keyword is used in body

            if (this.lookupParent) {
                this.addParentLookup(result, this.name);
            }

            result.add([ body, this.nl(-1) + '}' ]);

            return result;
        },
    };
})();

export FunctionStatement = proto (FunctionLiteral) { };

export GeneratorLiteral = proto (FunctionLiteral) { };
export GeneratorStatement = proto (GeneratorLiteral) { };

export AsyncLiteral = proto (FunctionLiteral) {

    callbackMarker: -1,

    toSourceNode: func() {

        // include Async module

        var parser = this.parser();
        parser.resultData.globals.add('___Async');
        parser.transform.usedBuiltins.add('async.adria');

        var result = this.csn();
        result.add('(function() {' + this.nl(1));
        result.add([ 'var ___self = ', FunctionLiteral->toSourceNode(), ';', this.nl() ]);
        result.add([ 'return function(', this.get('param_list').toSourceNode(false), ') {' + this.nl(1) ]);
        result.add('return new ___Async(___self.apply(this, arguments));' + this.nl(-1));
        result.add('};'+ this.nl(-1));
        result.add('})()');
        return result;
    },
};

export AsyncStatement = proto (AsyncLiteral) { };

export FunctionParamList = proto (AdriaNode) {

    toSourceNode: func(declare = true) {

        var result = this.csn();
        var functionNode = this.ancestor([ 'function', 'generator', 'async' ]);
        var scope = this.findScope();

        this.eachKey('item', func(node) {

            var name = node.get('name').toSourceNode();
            result.add(name);

            if (declare) {
                scope.addImplicit(name.toString());
            }

            // check for default args, push those to FunctionLiteral's defaultArgs property

            var valueNode = node.get('value');

            if (valueNode.isNode()) {

                var defaultArg = new SourceNode();
                defaultArg.add([ name, ' = (', name, ' !== undefined ? ', name, ' : (', valueNode.toSourceNode(), '))' ]);
                functionNode.defaultArgs.push(defaultArg);
            }
        });

        return result.join(', ');
    },
};

export BaseLiteral = proto (AdriaNode) {

    scan: func(state) {

        AdriaNode->scan(state);

        this.eachKey('ident', func(child) {
            this.checkDefined(child.value);
        });
    },

    toSourceNode: func() {

        var result = '';

        this.each(func(child) {
            switch (child.key) {
                //!case 'ident':
                case 'numeric':
                case 'string':
                case 'regexp':
                case 'brace':
                    result += this.csn(child.value);
                    break;

                default:
                    result += child.toSourceNode();
            }
        });

        return result;
    },
};

export DoWhileStatement = proto (Scope) {

    toSourceNode: func() {

        var result = this.csn();
        result.add('do {' + this.nl(1));

        var body = this.get('body').toSourceNode();
        result.add([ this.refsToSourceNode(), body ]);
        result.add([ this.nl(-1) + '} while (', this.get('condition').toSourceNode(), ');' ]);

        return result;
    },
};

export WhileStatement = proto (Scope) {

    toSourceNode: func() {

        var result = this.csn();
        result.add([ 'while (', this.get('condition').toSourceNode(), ') {' + this.nl(1) ]);

        var body = this.get('body').toSourceNode();
        result.add([ this.refsToSourceNode(), body ]);
        result.add(this.nl(-1) + '}');

        return result;
    },
};

export IfConditional = proto (Scope) {

    toSourceNode: func() {

        var result = this.csn();
        result.add([ 'if (', this.get('condition').toSourceNode(), ') {' + this.nl(1) ]);

        var body = this.get('body').toSourceNode();
        result.add([ this.refsToSourceNode(), body, this.nl(-1) + '}' ]);

        return result;
    },
};

export IfUnconditional = proto (Scope) {

    toSourceNode: func() {

        var result = this.csn();
        result.add([ '{' + this.nl(1) ]);

        var body = this.get('body').toSourceNode();
        result.add([ this.refsToSourceNode(), body, this.nl(-1) + '}' ]);

        return result;
    },
};

export IfStatement = proto (AdriaNode) {

    toSourceNode: func() {

        var result = this.csn();

        this.each(func(child) {

            if (child.key === 'else_if' || child.key === 'else') {
                result.add(' else ');
            }

            result.add(child.toSourceNode());
        });

        return result;
    },
};

export SwitchStatement = proto (AdriaNode) {

    toSourceNode: func() {

        var result = this.csn();
        result.add([ 'switch (', this.get('value').toSourceNode(), ') {', this.nl(1) ]);

        // cases

        this.eachKey('case', func(caseNode) {

            result.add(['case ', caseNode.get('match').toSourceNode(), ':' + this.nl(1) ]);
            result.add(caseNode.get('body').toSourceNode());
            result.add(this.nl(-1));
        });

        // default case

        var defaultNode = this.get('default');

        if (defaultNode.isNode()) {
            result.add('default:' + this.nl(1));
            result.add(defaultNode.get('body').toSourceNode());
            result.add(this.nl(-1));
        }

        result.add(this.nl(-1) + '}');

        return result;
    },
};

export ForCountStatement = proto (Scope) {

    toSourceNode: func() {

        var initNode = this.get('init');
        var init;

        if (initNode.value === 'var_def') {

            var varDefs = this.csn();
            var ownScope = this;

            initNode.eachKey('item', func(node) {

                var valueNode = node.get('value');
                var nameNode = node.get('name');

                ownScope.addLocal(nameNode.value);

                if (valueNode.isNode()) {
                    var varDef = new SourceNode();
                    varDef.add([ nameNode.toSourceNode(), ' = ', valueNode.toSourceNode() ]);
                    varDefs.add(varDef);
                } else {
                    varDefs.add(nameNode.toSourceNode);
                }
            });

            init = new SourceNode();
            init.add([ varDefs.join(', ') ]);

        } else {

            init = initNode.toSourceNode();
        }

        var test = this.get('test').toSourceNode();
        var condOp = this.get('cond_op').toSourceNode();

        this.nl(1);
        var body = this.get('body').toSourceNode();
        this.nl(-1);

        var result = this.csn();
        result.add(this.refsToSourceNode());
        result.add([ 'for (', init, '; ', test, ';', condOp, ') {' + this.nl(1) ]);
        result.add([ body, this.nl(-1) + '}' ]);

        return result;
    },
};

export ForInStatement = proto (Scope) {

    toSourceNode: func() {

        var keyNode = this.get('key');
        var valueNode = this.get('value');

        if (this.get('var').isNode()) {

            //var scope = this.findScope();
            this.addLocal(keyNode.value);

            if (valueNode.isNode()) {
                this.addLocal(valueNode.value);
            }
        }

        var source = this.get('source').toSourceNode();
        var key = keyNode.toSourceNode();

        this.nl(1);
        var body = this.get('body').toSourceNode();
        this.nl(-1);

        var result = this.csn();
        result.add(this.refsToSourceNode());
        result.add(['for (', key, ' in ', source, ') {' + this.nl(1) ]);

        if (valueNode.isNode()) {
            result.add([ valueNode.toSourceNode(), ' = ', source, '[', key, '];', this.nl() ]);
        }

        result.add([ body, this.nl(-1), '}' ]);

        return result;
    },
};

export ObjectLiteral = proto (AdriaNode) {

    assembleItemList: func() {

        var items = new SourceNode();

        this.each(func(child) {
            var item = new SourceNode();
            item.add(child.get('key').csn(child.get('key').value));
            item.add(': ');
            item.add(child.get('value').toSourceNode());
            items.add(item);
        });

        return items;
    },

    toSourceNode: func() {

        // indent now, so that children will be indented. correct for this by not indenting during return

        this.nl(1);

        var items = this.assembleItemList();
        var result = this.csn();

        if (items.toString().length >= 60) {

            result.add('{' + this.nl());
            result.add(items.join(',' + this.nl()));
            result.add(this.nl() + this.nl(-1) + '}');

        } else {

            this.nl(-1);
            result.add('{ ');
            result.add(items.join(', '));
            result.add(' }');
        }

        return result;
    }
};

(func() {
    var storageId = 1;

    export PropertyLiteral = proto (ObjectLiteral) {

        useStorage          : false,
        storageName         : null,
        defaultValueNode    : 'undefined', //!todo should be sourcenode, but returning sourcenodes also needs to be refactored. eventually should be AdriaNode

        assignmentToSourceNode: func(name, target) {

            var propertyBody = ObjectLiteral->toSourceNode();
            var result = this.csn();

            if (this.useStorage) {
                result.add('(Object.defineProperty(' + target + ', ' + this.storageName + ', {' + this.nl(1));
                result.add([ 'value: ', this.defaultValueNode, ',' + this.nl() ]);
                result.add('writable: true' + this.nl(-1));
                result.add('}),' + this.nl());
            }

            result.add([ 'Object.defineProperty(', target, ', ', name, ', ' ]);
            result.add(propertyBody);
            result.add(this.useStorage ? '))' : ')');
            return result;
        },

        assembleItemList: func() {

            // fetch storage and default settings in advance

            this.each(func(child) {

                var childKey = child.get('key');
                var childValue = child.get('value');

                if (childKey.value === 'default') {
                    this.defaultValueNode = childValue.toSourceNode();
                    this.useStorage = true;
                } else if (childKey.value === 'storage') {
                    this.storageName = childValue.value;
                    this.useStorage = true;
                }
            });

            // find name for property storage field

            if (this.storageName === null) {

                var nameSN = this.findName();

                if (nameSN === null) {
                    this.storageName = '\'___psf' + (storageId++) + '\'';
                } else {
                    this.storageName = '\'_' + nameSN.toString() + '\'';
                }
            }

            // process property fields

            var items = new SourceNode(); //!todo csn?

            this.each(func(child) {

                var childKey = child.get('key');

                if (childKey.value !== 'default' && childKey.value !== 'storage') {
                    var item = new SourceNode();
                    item.add(childKey.csn(childKey.value));
                    item.add(': ');
                    item.add(child.get('value').toSourceNode());
                    items.add(item);
                }
            });

            return items;
        },
    };
})();

export ArrayLiteral = proto (AdriaNode) {

    toSourceNode: func() {

        var items = new SourceNode();

        // indent now, so that children will be indented. correct for this by not indenting during return

        this.nl(1);

        this.each(func(child) {
            items.add(child.toSourceNode());
        });

        var result = this.csn();

        if (items.toString().length >= 60) {

            result.add('[' + this.nl());
            result.add(items.join(',' + this.nl()));
            result.add(this.nl() + this.nl(-1) + ']');

        } else {

            this.nl(-1);
            result.add('[ ');
            result.add(items.join(', '));
            result.add(' ]');
        }

        return result;
    },
};

export Expression = proto (AdriaNode) {

    wrapPrefix: new Set([
        'member', 'index', 'proto',
        'call', 'pcall', 'item'
    ]),

    preprocess: func(state) {

        AdriaNode->preprocess(state);

        // restructure async wraps

        var children = this.children;
        var id = children.length;
        var end = -1;

        while (id--) {
            if (children[id].key === 'wrap') {
                end = id;
            } else if (end > -1 && this.wrapPrefix.lacks(children[id].key)) {
                this.nest(id + 1, end);
                end = -1;
            } else if (end > -1 && end < children.length -1 && id === 0) {
                this.nest(0, end);
            }
        }
    },

    scan: func(state) {

        AdriaNode->scan(state);

        this.eachKey('ident', func(child) {
            this.checkDefined(child.value);
        });
    },

    toSourceNode: func() {

        var children = this.children;
        var propertyAssignSplit = -1;
        var result = this.csn();

        for (var id, child in children) {

            if (children[+id+1] !== undefined && children[+id+1].key === 'passignment_op') {
                propertyAssignSplit = +id + 1;
                break;
            }

            switch (child.key) {
                case 'member':
                    result.add(child.csn('.' + child.children[0].value));
                    break;
                case 'index':
                    result.add(child.csn('['));
                    result.add(child.toSourceNode());
                    result.add(child.csn(']'));
                    break;
                case 'proto':
                    result.add(child.csn('.prototype.' + child.children[0].value));
                    break;
                case 'call':
                case 'pcall':
                case 'wrap':
                case 'ident':
                    result.add(child.csn(child.toSourceNode()));
                    break;
                case 'brace_op':
                case 'xfix_op':
                    result.add(child.csn(child.value));
                    break;
                case 'unary_op':
                    result.add(child.csn(child.value.search(/[a-z]/) > -1 ? child.value + ' ' : child.value));
                    break;
                case 'binary_op':
                case 'assignment_op':
                case 'ternary_op':
                    result.add([ ' ', child.csn(child.value), ' ' ]);
                    break;
                default:
                    result.add(child.toSourceNode());
                    break;
            }
        }

        // property assignment

        if (propertyAssignSplit > -1) {

            //result.prepend('Object.defineProperty(');
            var target, name;

            var child = children[propertyAssignSplit - 1];

            switch (child.key) {
                case 'member':
                    target = result;
                    name = child.children[0].value;
                    //result.add(", '" + child.children[0].value + "',");
                    break;
                case 'index':
                    target = result;
                    name = child.toSourceNode();
                    //result.add([ ', ', child.toSourceNode(), ', ' ]);
                    break;
                case 'proto':
                    result.add('.prototype');
                    target = result;
                    name = "'" + child.children[0].value + "'";
                    //result.add(".prototype, '" + child.children[0].value + "', ");
                    break;
            }

            if (children[propertyAssignSplit].value === ':=') {
                result.prepend('Object.defineProperty(');
                result.add([', ', name]);
                result.add('{' + this.nl(1) + 'value: ');
                result.add(children[propertyAssignSplit + 1].toSourceNode());
                result.add(',' + this.nl() + 'writable: false' + this.nl(-1) + '})');
            } else {
                result = children[propertyAssignSplit + 1].assignmentToSourceNode(name, target);
            }
        }

        // async wrapping

        var wrapper = this.get('wrap');

        if (wrapper.isNode()) {

            var locals = '';
            var params = wrapper.params.join(', ');

            for (var id = 0; id < wrapper.params.length; id++) {
                locals += '___' + id + ', ';
            }

            result = this.csn([
                '(function(' + locals + '___callback) {', this.nl(1),
                'return ', result, ';', this.nl(-1),
                '}).bind(this' + (wrapper.params.length > 0 ? ', ' + params : '') + ')'
            ]);
        }

        return result;
    }
};

export ProtoLiteral = proto (AdriaNode) {

    constructorFunc: null,
    constructorArgs: null,
    constructorBody: null,
    constructorDefaults: null,
    lookupParent: false,
    name: '',

    constructor: func(key, value) {

        this.constructorArgs = [ ];
        this.constructorDefaults = [ ];
        AdriaNode->constructor(key, value);
    },

    toSourceNode: func() {

        // get own and parent name

        var nameSN = this.findName();

        if (nameSN !== null) {
            this.name = nameSN.toString();
        }

        var parentNode = this.get('parent');
        var haveParent = parentNode.isNode();

        // generate output

        var assignTo = '';

        if (this.value === 'proto_statement') {

            // statement requires assignment of wrapper

            this.parent.findScope().addLocal(this.name);
            assignTo = this.name + ' = ';
        }

        var result = this.csn(assignTo + '(function(' + (haveParent ? '___parent' : '') + ') {' + this.nl(1));
        var body = this.get('body').toSourceNode();

        // user- or default-constructor

        if (this.constructorBody !== null) {

            result.add('var ___self = function ' + this.name + '(');
            result.add(this.constructorArgs);
            result.add(') {' + this.nl(1));

            for (var id in this.constructorDefaults) {
                result.add(this.constructorDefaults[id]);
                result.add(';' + this.nl());
            }

            result.add(this.constructorFunc.refsToSourceNode());

            // dynamic parent lookup

            if (this.lookupParent) {
                this.addParentLookup(result, 'constructor', '___self');
            }

            result.add(this.constructorBody);
            result.add(this.nl(-1) + '};' + this.nl() + this.nl());

        } else {

            result.add('var ___self = function ' + this.name + '() {');

            if (haveParent) {
                result.add(this.nl(1) + '___parent.apply(this, arguments);' + this.nl(-1));
            }

            result.add('}' + this.nl() + this.nl());
        }

        // chain to parent

        if (haveParent) {
            result.add('___self.prototype = Object.create(___parent.prototype);' + this.nl());
            result.add('___self.prototype.constructor = ___self;' + this.nl());
        }

        // make name available inside proto block

        if (this.name !== '') {
            result.add('var ' + this.name + ' = ___self;' + this.nl());
        }

        // body elements

        result.add([this.nl(), body]);

        // close and return

        result.add(this.nl() + 'return ___self;' + this.nl(-1));
        result.add('})(');
        result.add(parentNode.toSourceNode());
        result.add(')');

        if (this.value === 'proto_statement') {
            result.add(';');
        }

        return result;
    },
};

export ProtoStatement = ProtoLiteral;

export NewProtoLiteral = proto (ProtoLiteral) {

    toSourceNode: func() {

        var result = this.csn();
        result.add('new (');
        result.add(parent->toSourceNode());
        result.add(')(');

        var paramList = this.get('param_list');

        if (paramList.isNode()) {
            result.add(paramList.toSourceNode());
        }

        result.add(')');

        return result;
    }
};

export ProtoBodyItem = proto (AdriaNode) {

    toSourceNode: func()  {

        var protoNode = this.ancestor(null, [ 'new_proto_literal', 'proto_literal', 'proto_statement' ]);
        //!var constructorName = protoNode.name;
        var keyNode = this.get('key');

        // set constructor attributes in ProtoLiteral, do the rest ourselves

        if (keyNode.value === 'constructor') {

            var functionNode = this.path('value.function');
            this.nl(1);
            protoNode.constructorFunc = functionNode;
            protoNode.constructorArgs = functionNode.get('param_list').toSourceNode();
            protoNode.constructorDefaults = functionNode.defaultArgs;
            protoNode.constructorBody = functionNode.get('body').toSourceNode();
            protoNode.lookupParent = functionNode.lookupParent;
            this.nl(-1);
            return this.csn();

        } else {

            var valueNode = this.get('value');
            var result;

            if  (valueNode.value === 'property_literal') {

                var name = (keyNode instanceof Ident === false ? keyNode.value : '"' + keyNode.value + '"');    //!todo quotes suck

                return this.csn([ valueNode.assignmentToSourceNode(name, '___self.prototype'), ';' + this.nl() ]);

            } else {

                var name = (keyNode instanceof Ident === false ? '[' + keyNode.value + ']' : '.' + keyNode.value);

                result = this.csn('___self.prototype' + name + ' = ');
                result.add(valueNode.toSourceNode());
                result.add(';' + this.nl());
                return result;
            }
        }
    }
};

export ReturnStatement = proto (AdriaNode) {

    toSourceNode: func() {

        var result = this.csn();
        var type = this.get('type');

        result.add([ type.csn(type.value), ' ' ]);
        result.add(this.get('value').toSourceNode());
        result.add(';' + this.nl());

        return result;
    },
};

export FlowStatement = ReturnStatement;

export YieldLiteral = proto (AdriaNode) {

    toSourceNode: func() {

        var result = this.csn();
        //var type = this.get('type');

        //result.add([ type.csn(type.value), ' ' ]);
        result.add([ 'yield ', this.get('value').toSourceNode() ]);

        return result;
    },
};

export AwaitLiteral = YieldLiteral;

export Try = proto (Scope) {

    toSourceNode: func() {

        var result = this.csn();
        result.add('try {' + this.nl(1));
        result.add(this.get('body').toSourceNode());
        result.add(this.nl(-1) + '}');
        return result;
    },
};

(func() {
    var catchId = 1;

    export Catch = proto (AdriaNode) {

        exceptionName: '',

        toSourceNode: func() {

            this.exceptionName = '___exc' + (catchId++);

            var result = this.csn();
            result.add(' catch (' + this.exceptionName + ') {' + this.nl(1));

            this.each(func(node, first, last) {

                // handle non-first catch all and catch-specific

                if (node instanceof CatchAll && first !== true) {
                    result.add([ ' else {' + this.nl(1), node.toSourceNode(), this.nl(-1) + '}' ]);
                } else if (node instanceof CatchSpecific && first !== true) {
                    result.add([ ' else ', node.toSourceNode(), ]);
                } else {
                    result.add(node.toSourceNode());
                }

                // last block not a catch-all block, rethrow

                if (last && node instanceof CatchAll !== true) {
                    result.add(' else { ' + this.nl(1));
                    result.add('throw ' + this.exceptionName + ';' + this.nl());
                    result.add(this.nl(-1) + '}');
                }
            });

            result.add(this.nl(-1) + '}');
            return result;
        },
    };
})();

export CatchSpecific = proto (Scope) {

    toSourceNode: func() {

        var catchNode = this.findProto(Catch);
        var valueNode = this.get('value');

        this.addLocal(valueNode.value);

        var result = this.csn();
        result.add([ 'if (' + catchNode.exceptionName + ' instanceof ', this.get('type').toSourceNode(), ') {' + this.nl(1) ]);
        result.add([ 'var ', valueNode.toSourceNode(), ' = ' + catchNode.exceptionName + ';' + this.nl() ]);
        result.add(this.get('body').toSourceNode());
        result.add(this.nl(-1) + '}');
        return result;
    },
};

export CatchAll = proto (Scope) {

    toSourceNode: func() {

        var catchNode = this.findProto(Catch);
        var valueNode = this.get('value');

        this.addLocal(valueNode.value);

        var result = this.csn();
        result.add([ 'var ', valueNode.toSourceNode(), ' = ' + catchNode.exceptionName + ';' + this.nl() ]);
        result.add(this.get('body').toSourceNode());
        return result;
    },

};

export Finally = proto (Scope) {

    toSourceNode: func() {

        var result = this.csn();
        result.add(' finally {' + this.nl(1));
        result.add(this.get('body').toSourceNode());
        result.add(this.nl(-1) + '}');
        return result;
    },
};

export ThrowStatement = proto (AdriaNode) {

    toSourceNode: func() {

        var result = this.csn('throw ');
        result.add(this.get('exception').toSourceNode());
        result.add(';' + this.nl());

        return result;
    },
};

export AssertStatement = proto (AdriaNode) {

    toSourceNode: func() {

        var result = this.csn();

        if (this.parser().transform.options.assert) {

            var params = this.get('call');
            var paramsSN = params.toSourceNode(false);

            result.add([ 'assert(', paramsSN ]);

            // if only one parameter, add textual version of assertion as secondary parameter

            var numParams = 0;

            params.each(func(node, first) {
                numParams++;
            });

            if (numParams < 2) {
                result.add([ ", '" + paramsSN.toString().jsify("'") + "'" ]);
            }

            result.add(');' + this.nl());
        }

        return result;
    }
};

export Statement = proto (AdriaNode) {

    toSourceNode: func() {

        var type = this.children[0].key;
        var result = this.csn();

        result.add(AdriaNode->toSourceNode());

        switch (type) {
            case 'expression':
                result.add(';' + this.nl());
                break;

            default:
                result.add(this.nl());
        }

        return result;
    },
};

export InterruptibleStatement = Statement;

var AdriaFileNode = proto (AdriaNode) {

    /**
     * relative nodejs paths have to be prefixed with ./ or ../
     *
     * @param filename
     * @param boolean true if path is a relative nodejs path
     */
    isRelativePath: func(filename) {
        return filename.slice(0, 2) === './' || filename.slice(0, 3) === '../';
    },

    makeBaseRelative: func(filename, parser) {

        var absName = path.dirname(parser.file) + '/' + filename;
        return path.relative(parser.transform.options.basePath, absName);
    },

    resolvePath: func(fileName, parser) {

        var options = parser.transform.options;
        var relname;

        if (this.isRelativePath(fileName)) {

            // check project base

            relname = this.makeBaseRelative(fileName, parser);

            if (fs.existsSync(options.basePath + relname)) {
                return path.normalize(relname);
            }

        } else {

            // try paths

            for (var id in options.paths) {

                relname = options.paths[id] + fileName;

                if (fs.existsSync(options.basePath + relname)) {
                    return path.normalize(relname);
                }
            }
        }

        return null;
    },
};

export ResourceLiteral = proto (AdriaFileNode) {

    toSourceNode: func() {

        var parser = this.parser();
        var options = parser.transform.options;
        var fileNode = this.get('file');
        var fileName = fileNode.toSourceNode().toString().slice(1, -1);

        var resolvedName = this.resolvePath(fileName, parser);

        if (resolvedName !== null) {
            parser.resultData.resources.add(resolvedName);
        } else {
            throw new ASTException('Could not find resource "' + fileName + '"', this);
        }

        var result = this.csn();
        result.add('resource(');
        result.add(fileNode.csn("'" + resolvedName + "'"));
        result.add(')');
        return result;
    },
};

export RequireLiteral = proto (AdriaFileNode) {

    toSourceNode: func() {

        var parser = this.parser();
        var options = parser.transform.options;
        var fileNode = this.get('file');
        var moduleName = fileNode.toSourceNode().toString().slice(1, -1);
        var result = this.csn();
        var requireFunction = 'require';
        var resolvedName;

        // check builtins

        resolvedName = util.normalizeExtension(moduleName, options.fileExt);

        if (parser.transform.builtins[resolvedName] !== undefined) {

            // module is builtin, set flag for inclusion by transform

            parser.transform.usedBuiltins.add(resolvedName);
            moduleName = resolvedName;

            if (resolvedName === 'async.adria') {
                parser.resultData.globals.add('___Async'); //!todo add a useBuiltin function to handle cases like this
            }

            if (options.platform === 'node') {
                requireFunction = '___require';
            }

        } else {

            // check if the require is an Adria module and needs to be included

            resolvedName = this.resolvePath(util.normalizeExtension(moduleName, options.fileExt), parser);

            if (resolvedName !== null) {

                moduleName = resolvedName;
                parser.resultData.requires.add(moduleName);

                if (options.platform === 'node') {
                    requireFunction = '___require';
                }

            } else if (options.platform !== 'node' || moduleName.hasPostfix(options.fileExt)) {

                throw new ASTException('Could not find require "' + moduleName + '"', this);
            }
        }

        result.add(requireFunction + '(');
        result.add(fileNode.csn("'" + moduleName + "'"));
        result.add(')');
        return result;
    },
};

export ModuleStatement = proto (AdriaNode) {

    toSourceNode: func() {

        var name = this.get('name').value;
        var moduleNode = this.findProto(Module);
        moduleNode.setModuleExport(name);

        var result = this.csn();
        result.add(name);
        result.add(' = ');
        result.add(this.get('value').toSourceNode());
        result.add(';' + this.nl());
        return result;
    },
};

export ExportStatement = proto (AdriaNode) {

    toSourceNode: func() {

        var name = this.get('name').value;
        var moduleNode = this.findProto(Module);
        moduleNode.addExport(name);

        var result = this.csn();
        result.add(name);
        result.add(' = ');
        result.add(this.get('value').toSourceNode());
        result.add(';' + this.nl());
        return result;
    },
};

export GlobalDef = proto (AdriaNode) {

    toSourceNode: func() {

        var valueNode, nameNode;
        var globals = this.parser().resultData.globals;
        var result = this.csn();
        var nl = this.nl();

        this.eachKey('item', func(node) {
            nameNode = node.get('name');
            valueNode = node.get('value');

            globals.add(nameNode.value);

            if (valueNode.isNode()) {
                result.add(nameNode.value + ' = ');
                result.add(valueNode.toSourceNode());
                result.add(';' + nl);
            }
        });

        return result;
    },
};

export ParentLiteral = proto (AdriaNode) {

    toSourceNode: func() {
        this.ancestor('function').lookupParent = true;
        return this.csn('___p');
    }
};

export StorageLiteral = proto (AdriaNode) {

    toSourceNode: func() {

        var propertyItem = this.ancestor(null, 'property_accessor_item');
        var propertySelf = propertyItem.parent;
        var propertyFunction = propertyItem.get('value').get('function');

        if (propertySelf instanceof PropertyLiteral && propertyFunction instanceof FunctionLiteral) {

            propertySelf.useStorage = true;
            var contextName = propertyFunction.storeContext();
            return this.csn(contextName + '[' + propertySelf.storageName + ']');
        }

        throw new ASTException('Invalid use of "storage" literal', this);
    }
};

export ValueType = proto (AdriaNode) {

    toSourceNode: func() {
        return this.csn(this.value);
    }
};

export Ident = proto (ValueType) {

    toSourceNode: func() {
        var name = this.findScope().findRef(this.value);
        return this.csn(name !== null ? name : this.value);
    }
};
export Name = Ident; //!todo derive from ValueType
export String = proto (ValueType) { };
export Numeric = proto (ValueType) { };

export VarDef = proto (AdriaNode) {

    toSourceNode: func() {

        var valueNode, nameNode;
        var scope = this.findScope();
        var result = this.csn();
        var nl = this.nl();

        this.eachKey('item', func(node) {
            nameNode = node.get('name');
            valueNode = node.get('value');

            scope.addLocal(nameNode.value);

            if (valueNode.isNode()) {
                result.add([ nameNode.toSourceNode(), ' = ', valueNode.toSourceNode(), ';' + nl ]);
            }
        });

        return result;
    },
};

export ImportStatement = proto (AdriaNode) {

    toSourceNode: func() {

        var scope = this.findScope();

        this.eachKey('item', func(node) {
            scope.addImplicit(node.value);
        });

        return this.csn();
    },
};
