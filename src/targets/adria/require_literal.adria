
var util = require('../../util');
var FileNode = require('./base/file_node');
var ASTException = require('../../language_parser/ast_exception');

module RequireLiteral = proto (FileNode) {

    toSourceNode: func() {

        var parser = this.parser();
        var options = parser.transform.options;
        var fileNode = this.get('file');
        var moduleName = fileNode.toString().slice(1, -1);
        var requireFunction = 'require';
        var resolvedName;

        // check builtins

        resolvedName = util.normalizeExtension(moduleName, options['extension']);

        if (parser.transform.builtins[resolvedName] !== undefined) {

            // module is builtin, set flag for inclusion by transform and update modulename

            parser.transform.usedBuiltins.add(resolvedName);
            moduleName = resolvedName;

            if (resolvedName === 'async.adria') {
                parser.resultData.globals.add('___Async'); //!todo add a useBuiltin function to handle cases like this
            }

        } else {

            // check if the require is an Adria module and needs to be included

            resolvedName = this.resolvePath(util.normalizeExtension(moduleName, options['extension']), parser);

            if (resolvedName !== null) {

                // resolved to an adria file, include in application

                moduleName = resolvedName;
                parser.resultData.requires.add(moduleName);

            } else if (options['platform'] === 'node' && moduleName.hasPostfix(options['extension']) === false) {

                // seems to be a node module, use node require function

                requireFunction = '___require';

            } else {

                throw new ASTException('Could not find require "' + moduleName + '"', this);
            }
        }

        return this.csn([ requireFunction + '(', fileNode.csn("'" + moduleName + "'"), ')' ]);
    },
};
