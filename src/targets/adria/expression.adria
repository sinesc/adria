
var Set = require('astd/set');
var AdriaNode = require('./adria_node');

module Expression = proto (AdriaNode) {

    wrapPrefix: new Set([
        'member', 'index', 'proto',
        'call', 'pcall', 'item'
    ]),

    preprocess: func(state) {

        AdriaNode->preprocess(state);

        // restructure async wraps

        var children = this.children;
        var id = children.length;
        var end = -1;

        while (id--) {
            if (children[id].key === 'wrap') {
                end = id;
            } else if (end > -1 && this.wrapPrefix.lacks(children[id].key)) {
                this.nest(id + 1, end);
                end = -1;
            } else if (end > -1 && end < children.length -1 && id === 0) {
                this.nest(0, end);
            }
        }
    },

    scan: func(state) {

        AdriaNode->scan(state);

        this.eachKey('ident', func(child) {
            this.checkDefined(child.value);
        });
    },

    toSourceNode: func() {

        var children = this.children;
        var propertyAssignSplit = -1;
        var result = this.csn();

        for (var id, child in children) {

            if (children[+id+1] !== undefined && children[+id+1].key === 'passignment_op') {
                propertyAssignSplit = +id + 1;
                break;
            }

            switch (child.key) {
                case 'member':
                    result.add(child.csn('.' + child.children[0].value));
                    break;
                case 'index':
                    result.add(child.csn('['));
                    result.add(child.toSourceNode());
                    result.add(child.csn(']'));
                    break;
                case 'proto':
                    result.add(child.csn('.prototype.' + child.children[0].value));
                    break;
                case 'call':
                case 'pcall':
                case 'wrap':
                case 'ident':
                    result.add(child.csn(child.toSourceNode()));
                    break;
                case 'brace_op':
                case 'xfix_op':
                    result.add(child.csn(child.value));
                    break;
                case 'unary_op':
                    result.add(child.csn(child.value.search(/[a-z]/) > -1 ? child.value + ' ' : child.value));
                    break;
                case 'binary_op':
                case 'assignment_op':
                case 'ternary_op':
                    result.add([ ' ', child.csn(child.value), ' ' ]);
                    break;
                default:
                    result.add(child.toSourceNode());
                    break;
            }
        }

        // property assignment

        if (propertyAssignSplit > -1) {

            var target, name;
            var child = children[propertyAssignSplit - 1];

            switch (child.key) {
                case 'member':
                    target = result;
                    name = "'" + child.children[0].value + "'";
                    break;
                case 'index':
                    target = result;
                    name = child.toSourceNode();
                    break;
                case 'proto':
                    result.add('.prototype');
                    target = result;
                    name = "'" + child.children[0].value + "'";
                    break;
            }

            // handle readonly assignment

            if (children[propertyAssignSplit].value === ':=') {
                result.prepend('Object.defineProperty(');
                result.add([ ', ', name, ', {' + this.nl(1) + 'value: ' ]);
                result.add(children[propertyAssignSplit + 1].toSourceNode());
                result.add(',' + this.nl() + 'writable: false' + this.nl(-1) + '})');
            } else {
                result = children[propertyAssignSplit + 1].assignmentToSourceNode(name, target);
            }
        }

        // async wrapping

        var wrapper = this.get('wrap');

        if (wrapper.isNode()) {

            var locals = '';
            var params = wrapper.params.join(', ');

            for (var id = 0; id < wrapper.params.length; id++) {
                locals += '___' + id + ', ';
            }

            result = this.csn([
                '(function(' + locals + '___callback) {', this.nl(1),
                'return ', result, ';', this.nl(-1),
                '}).bind(this' + (wrapper.params.length > 0 ? ', ' + params : '') + ')'
            ]);
        }

        return result;
    }
};
