/*
 * Adria transcompiler
 *
 * Copyright (C) 2014 Dennis MÃ¶hlmann <mail@dennismoehlmann.de>
 * Licensed under the MIT license.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var Node = require('./base/node');

module ProtoLiteral = proto (Node) {

    constructorSN: null,
    provideParent: false,
    name: '',

    constructor: func(string key, string value) {

        parent->constructor(key, value);
    },

    toSourceNode: func() {

        // get own and parent name

        var nameSN = this.findName();

        if (nameSN !== null) {
            this.name = nameSN.toString();
        }

        var parentNode = this.get('parent');
        var haveParent = parentNode.isNode();
        var blankParent = (haveParent ? parentNode.toString() === 'null' : false);
        var chainToParent = haveParent && blankParent === false;
        var refName = this.name !== '' ? this.name : 'Anonymous';

        // generate output

        var result = this.csn();

        if (this.value === 'proto_statement') {

            // statement requires assignment of wrapper

            var mangledName = this.parent.findScope().addLocal(this.name);
            result.add(mangledName + ' = ');
        }

        result.add('(function(' + (chainToParent ? '___parent' : '') + ') {' + this.nl(1));

        var body = this.get('body').toSourceNode();

        // user-defined or default-constructor

        if (this.constructorSN !== null) {
            result.add([ this.constructorSN, ';' + this.nl() ]);
        } else {
            this.addDefaultConstructor(result, refName, chainToParent);
        }

        // chain to parent

        if (haveParent) {
            result.add(refName + '.prototype = Object.create(' + (blankParent ? 'null' : '___parent.prototype') + ');' + this.nl());
            result.add(refName + '.prototype.constructor = ' + refName + ';' + this.nl());
        }

        // body elements

        result.add(body);

        // close and return

        result.add('return ' + refName + ';' + this.nl(-1));
        result.add('})(');

        if (chainToParent) {
            result.add(parentNode.toSourceNode());
        }

        result.add(')');

        if (this.value === 'proto_statement') {
            result.add(';');
        }

        return result;
    },

    addDefaultConstructor: func(result, refName, chain) {

        result.add('function ' + refName + '() {');

        if (chain) {
            result.add(this.nl(1) + '___parent.apply(this, arguments);' + this.nl(-1));
        }

        result.add('}' + this.nl());
    },
};
