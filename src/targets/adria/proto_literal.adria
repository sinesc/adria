/*
 * Adria transcompiler
 *
 * Copyright (C) 2014 Dennis MÃ¶hlmann <mail@dennismoehlmann.de>
 * Licensed under the MIT license.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var FunctionNode = require('./base/function_node');

module ProtoLiteral = proto (FunctionNode) {

    constructorFunc: null,
    constructorArgs: null,
    constructorBody: null,
    constructorDefaults: null,
    provideParent: false,
    name: '',

    constructor: func(key, value) {

        this.constructorArgs = [ ];
        this.constructorDefaults = [ ];
        parent->constructor(key, value);
    },

    toSourceNode: func() {

        // get own and parent name

        var nameSN = this.findName();

        if (nameSN !== null) {
            this.name = nameSN.toString();
        }

        var parentNode = this.get('parent');
        var haveParent = parentNode.isNode();
        var blankParent = (haveParent ? parentNode.toString() === 'null' : false);

        // generate output

        var result = this.csn();

        if (this.value === 'proto_statement') {

            // statement requires assignment of wrapper

            var mangledName = this.parent.findScope().addLocal(this.name);
            result.add(mangledName + ' = ');
        }

        result.add('(function(' + (haveParent && blankParent === false ? '___parent' : '') + ') {' + this.nl(1));

        var body = this.get('body').toSourceNode();

        // user- or default-constructor

        if (this.constructorBody !== null) {
//!todo refactor this crap
            result.add('var ___self = function ' + this.name + '(');
            result.add(this.constructorArgs);
            result.add(') {' + this.nl(1));

            for (var id in this.constructorDefaults) {
                result.add([ this.constructorDefaults[id], this.nl() ]);
            }

            result.add(this.constructorFunc.refsToSourceNode());

            // dynamic parent lookup

            if (this.provideParent) {
                this.getParentLookupCode(result, 'constructor', '___self');
            }

            result.add(this.constructorBody);
            result.add(this.nl(-1, result) + '};' + this.nl());

        } else {

            result.add('var ___self = function ' + this.name + '() {');

            if (haveParent && blankParent === false) {
                result.add(this.nl(1) + '___parent.apply(this, arguments);' + this.nl(-1));
            }

            result.add('}' + this.nl());
        }

        // chain to parent

        if (haveParent) {
            result.add('___self.prototype = Object.create(' + (blankParent ? 'null' : '___parent.prototype') + ');' + this.nl());
            result.add('___self.prototype.constructor = ___self;' + this.nl());
        }

        // make name available inside proto block

        if (this.name !== '') {
            result.add('var ' + this.name + ' = ___self;' + this.nl());
        }

        // body elements

        result.add(body);

        // close and return

        result.add('return ___self;' + this.nl(-1));
        result.add('})(');

        if (haveParent && blankParent === false) {
            result.add(parentNode.toSourceNode());
        }

        result.add(')');

        if (this.value === 'proto_statement') {
            result.add(';');
        }

        return result;
    },
};
