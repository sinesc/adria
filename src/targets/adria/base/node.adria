/*
 * Adria transcompiler
 *
 * Copyright (C) 2014 Dennis MÃ¶hlmann <mail@dennismoehlmann.de>
 * Licensed under the MIT license.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var LanguageParser = require('../../../language_parser');
var ASTException = LanguageParser.ASTException;
var CaptureNode = LanguageParser.CaptureNode;

module Node = proto (CaptureNode) {

    /**
     * constructor-type findScope will search for (should be set to Scope)
     */
    Scope: null,

    /**
     * find this node's scope
     *
     * @param boolean fromParent default false, if true start looking at parent instead of this
     * @return scope node/null
     */
    findScope: func(boolean fromParent = false) {
        return this.findProto(Node::Scope, null, fromParent, null);
    },

    /**
     * returns true if the name is defined in current scope or above
     *
     * @param string name
     */
    checkDefined: func(string name) {

        var parser = this.parser;

        if (parser.transform.implicits.has(name) || parser.transform.globals.has(name)) {
            return;
        }

        if (this.findScope().getRef(name) !== null) {
            return;
        }

        throw new ASTException('Undefined reference "' + name + '"', this);
    },

    /**
     * find name on left side of assignment or proto body item
     *
     * @return SourceNode for name or null
     */
    findName: func() {

        var result = null;
        var nameNode = this.get('name');

        if (nameNode.isNode() === false) {

            nameNode = this.ancestor(null, ['module_statement', 'export_statement', 'expression', 'dec_def', 'proto_body_item']);

            if (nameNode.isNode()) {

                // fetch from declaration, proto-literal item's left side or expression

                if (nameNode.value === 'dec_def' || nameNode.value === 'module_statement' || nameNode.value === 'export_statement') {

                    result = nameNode.get('name').toSourceNode();

                } else if (nameNode.value === 'proto_body_item') {

                    result = nameNode.get('key').toSourceNode();

                } else if (nameNode.value === 'expression') {

                    result = nameNode.findAssignee();
                }
            }

        } else {

            result = nameNode.toSourceNode();
        }

        return result;
    },

    /**
     * fetches the rightmost name on the left side of an assignment
     * i.e. name of (a || b).node.name
     *
     * @return SourceNode for name or null
     */
    findAssignee: func() {

        var children = this.children;
        var found = -1;
        var result = null;

        for (var id = 0; id < children.length; id++) {
            if (children[id].key === 'assignment_op') {
                found = id - 1;
                break;
            }
        }

        if (found !== -1) {

            var child = children[found];

            if (child.value === 'access_operation_member' || child.value === 'access_operation_proto') {
                result = child.csn(child.get('item').value);
            }

            if (child.key === 'ident') {
                result = child.csn(child.toSourceNode());
            }
        }

        return result;
    },

    /**
     * toString implementation
     *
     * @return node string representation
     */
    toString: func() {
        return this.toSourceNode().toString();
    },

    /**
     * when compiling to ES5, this function is used instead of toSourceNode()
     *
     * @return SourceNode
     */
    toES5SourceNode: func() {
        return this.toSourceNode();
    },

};