/*
 * Adria transcompiler
 *
 * Copyright (C) 2014 Dennis MÃ¶hlmann <mail@dennismoehlmann.de>
 * Licensed under the MIT license.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var Map = require('astd/map');
var LanguageParser = require('../../../language_parser');
var ASTException = LanguageParser.ASTException;
var CaptureNode = LanguageParser.CaptureNode;

module Node = proto (CaptureNode) {

    /**
     * @var function constructor-type findScope will search for (should be set to Scope)
     */
    Scope: null,

    /**
     * @var Map references this node would have marked as used, had the definition already been processed
     */
    toBeMarkedAsUsed: null,

    prescan: func(object state) {

        if (this.toBeMarkedAsUsed !== null) {

            for (var name, fromParent in this.toBeMarkedAsUsed.data) {
                this.markUsed(name, fromParent);
            }
        }

        CaptureNode->prescan(state);
    },

    /**
     * increases usage count for give name in it's origin scope, effectively marking it as "used"
     *
     * @param string name reference name
     * @param boolean fromParent skip current node in search
     * @return boolean success
     */
    markUsed: func(string name, fromParent = false) {

        var refScope = this.findRefScope(name, fromParent);

        if (refScope !== null) {

            refScope.usages.inc(name);
            return true;

        } else {

            if (this.toBeMarkedAsUsed === null) {
                this.toBeMarkedAsUsed = new Map();
            }

            if (this.toBeMarkedAsUsed.lacks(name)) {
                this.toBeMarkedAsUsed.set(name, fromParent);
            }

            return false;
        }
    },

    /**
     * find this node's scope
     *
     * @param boolean fromParent default false, if true start looking at parent instead of this
     * @return scope node/null
     */
    findScope: func(boolean fromParent = false) {
        return this.findProto(Node::Scope, null, fromParent, null);
    },

    /**
     * finds (parent-)scope defining given name
     *
     * @param string name
     * @param boolean fromParent skip current node in search
     * @return Scope/null
     */
    findRefScope: func(string name, fromParent = false) {

        var current = this.findScope(fromParent);

        do {
            if (current.getOwnRef(name) !== null) {
                return current;
            }
        } while ((current = current.findScope(true)) !== null);

        return current;
    },

    /**
     * returns true if the name is defined in current scope or above,
     * false if the name is implicitly known or throws if the name is
     * not known
     *
     * @param string name
     * @return boolean
     */
    checkDefined: func(string name) {

        if (this.parser.transform.implicits.has(name) || this.parser.transform.globals.has(name)) {
            return false;
        }

        if (this.findScope().getRef(name) !== null) {
            return true;
        }

        throw new ASTException('Undefined reference "' + name + '"', this);
    },

    /**
     * find name on left side of assignment or proto body item
     *
     * @return SourceNode for name or null
     */
    findName: func() {

        var result = null;
        var nameNode = this.get('name');

        if (nameNode.isNode() === false) {

            nameNode = this.ancestor(null, ['module_statement', 'export_statement', 'expression', 'dec_def', 'proto_body_item']);

            if (nameNode.isNode()) {

                // fetch from declaration, proto-literal item's left side or expression

                if (nameNode.value === 'dec_def' || nameNode.value === 'module_statement' || nameNode.value === 'export_statement') {

                    result = nameNode.get('name').toSourceNode();

                } else if (nameNode.value === 'proto_body_item') {

                    result = nameNode.get('key').toSourceNode();

                } else if (nameNode.value === 'expression') {

                    result = nameNode.findAssignee();
                }
            }

        } else {

            result = nameNode.toSourceNode();
        }

        return result;
    },

    /**
     * fetches the rightmost name on the left side of an assignment
     * i.e. name of (a || b).node.name
     *
     * @return SourceNode for name or null
     */
    findAssignee: func() {

        var children = this.children;
        var found = -1;
        var result = null;

        for (var id = 0; id < children.length; id++) {
            if (children[id].key === 'assignment_op') {
                found = id - 1;
                break;
            }
        }

        if (found !== -1) {

            var child = children[found];

            if (child.value === 'access_operation_member' || child.value === 'access_operation_proto') {
                result = child.csn(child.get('item').value);
            }

            if (child.key === 'ident') {
                result = child.csn(child.toSourceNode());
            }
        }

        return result;
    },

    /**
     * toString implementation
     *
     * @return node string representation
     */
    toString: func() {
        return this.toSourceNode().toString();
    },

};