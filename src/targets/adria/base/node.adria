
var LanguageParser = require('../../../language_parser');
var ASTException = LanguageParser.ASTException;
var CaptureNode = LanguageParser.CaptureNode;

module Node = proto (CaptureNode) {

    /**
     * constructor-type findScope will search for (should be set to Scope)
     */
    Scope: null,

    /**
     * find this node's scope
     *
     * @param boolean fromParent default false, if true start looking at parent instead of this
     * @return scope node/null
     */
    findScope: func(fromParent = false) {
        return this.findProto(Node::Scope, null, fromParent, null);
    },

    /**
     * returns true if the name is defined in current scope or above
     *
     * @param string name
     */
    checkDefined: func(name) {

        var parser = this.parser();

        if (parser.transform.implicits.has(name) || parser.transform.globals.has(name)) {
            return;
        }

        if (this.findScope().findRef(name) !== null) {
            return;
        }

        throw new ASTException('Undefined reference "' + name + '"', this);
    },

    /**
     * find name on left side of assignment or proto body item
     *
     * @return SourceNode for name or null
     */
    findName: func() {

        var result = null;
        var nameNode = this.get('name');

        if (nameNode.isNode() === false) {

            nameNode = this.ancestor(null, ['module_statement', 'export_statement', 'expression', 'dec_def', 'proto_body_item']);

            if (nameNode.isNode()) {

                // fetch from declaration, protoliteral item's left side or expression

                if (nameNode.value === 'dec_def' || nameNode.value === 'module_statement' || nameNode.value === 'export_statement') {

                    result = nameNode.get('name').toSourceNode();

                } else if (nameNode.value === 'proto_body_item') {

                    result = nameNode.get('key').toSourceNode();

                } else if (nameNode.value === 'expression') {

                    result = nameNode.findAssignee();
                }
            }

        } else {
            result = nameNode.toSourceNode();
        }

        return result;
    },

    /**
     * fetches the rightmost name on the left side of an assignment
     * i.e. name of (a || b).node.name
     *
     * @return SourceNode for name or null
     */
    findAssignee: func() {

        var children = this.children;
        var found = -1;
        var result = null;

        for (var id = 0; id < children.length; id++) {
            if (children[id].key === 'assignment_op') {
                found = id - 1;
                break;
            }
        }

        if (found !== -1) {

            var child = children[found];

            if (child.value === 'access_operation_member' || child.value === 'access_operation_proto') {
                result = child.csn(child.get('item').value);
            }

            if (child.key === 'ident') {
                result = child.csn(child.toSourceNode());
            }
        }

        return result;
    },

    /**
     * toString implementation
     *
     * @return node string representation
     */
    toString: func() {
        return this.toSourceNode().toString();
    },

};