/*
 * The MIT License (MIT)
 *
 * Copyright (C) 2013 Dennis Möhlmann <mail@dennismoehlmann.de>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var fs = require('fs');
var path = require('path');
var util = require('../util');
var SourceNode = require('source-map').SourceNode;
var Template = require('../template');
var Transform = require('../transform');
var AdriaParser = require('./adria_parser');

/**
 * Transforms a set of input files into one or more output files using the
 * Adria language transformation definition
 *
 * @see Transform
 */
module AdriaTransform = proto (Transform) {

    /**
     * populated by globals node, names of application-wide globals
     */
    globals: null,
    requires: null,
    modules: null,
    resources: null,
    requiresDone: null,
    sourceCode: null,
    protoParser: null,

    constructor: function(piped) {

        Transform->constructor(piped);

        this.globals        = new util.Set();
        this.requires       = new util.Set();
        this.resources      = new util.Set();
        this.requiresDone   = new util.Set();
        this.modules        = [ ];
        this.sourceCode     = { };

        // defaults

        var options = this.options;

        options['no-link'] = (options['no-link'] === undefined ? false : options['no-link']);
        options['no-map'] = (options['no-map'] === undefined ? false : options['no-map']);
        options['no-framework'] = (options['no-framework'] === undefined ? false : options['no-framework']);
        options['no-blanks'] = (options['no-blanks'] === undefined ? false : options['no-blanks']);
        options['no-scan'] = (options['no-scan'] === undefined ? false : options['no-scan']);
        options.fileExt = (options.fileExt === undefined ? '.adria' : options.fileExt);
        options.platform = (options.platform === undefined ? 'web' : options.platform);

        options['tweak-exports'] = (options['tweak-exports'] === undefined ? false : options['tweak-exports']);
        options['tweak-nostrict'] = (options['tweak-nostrict'] === undefined ? false : options['tweak-nostrict']);
    },

    initOptions: function() {

        Transform->initOptions(this);

        this.defineOptions({
            'file-extension': function(extension) {
                this.fileExt = '.' + extension;
            },
            'platform': function(platform) {
                this.platform = platform;
            }
        });
    },

    /**
     * returns the full path to given filename
     *
     * @param filename
     * @return absolute path (including filename) to module
     */
    resolveModule: function(filename) {

        var fullname = this.options.basePath + filename;

        // check if file exists, if not scan path

        if (fs.existsSync(fullname) !== true) {

            var paths = this.options.paths;
            var current = fullname;

            for (var id in paths) {

                current = this.options.basePath + paths[id] + filename;

                if (fs.existsSync(current)) {
                    fullname = current;
                    break;
                }
            }
        }

        return path.normalize(fullname);
    },

    /**
     * build a module and its dependencies recursively and push the
     * result onto AdriaTransform::modules
     *
     * @param moduleName name of the module
     * @param data module source code
     */
    buildModule: function(moduleName, data) {

        // create parser from proto-parser

        var parser = this.protoParser.clone();
        parser.moduleName = moduleName;

        if (data === undefined) {
            parser.loadSource(this.resolveModule(moduleName));
        } else {
            parser.setSource(moduleName, data);
        }

        // generate result

        parser.preprocess({ });
        var result = parser.output();

        // add globals and requires to transform

        var requires = parser.resultData.requires;

        this.requiresDone.add(moduleName);

        for (var name in requires.data) {
            if (this.requiresDone.has(name) === false) {
                this.buildModule(name);
            }
        }

        // these are used in the template

        this.requires = this.requires.merge(parser.resultData.requires);
        this.globals = this.globals.merge(parser.resultData.globals);
        this.resources = this.resources.merge(parser.resultData.resources);

        // scan module for undefined variables

        if (this.options['no-scan'] !== true) {
            parser.scan({ });
        }

        // push module after all dependencies have been resolved

        this.modules.push({ filename: parser.file, sourceCode: parser.sourceCode, result: result });
    },

    /**
     * generate JavaScript SourceNode output tree from built modules
     */
    generateOutputTree: function() {

        var options = this.options;
        var node = new SourceNode(null, null);
        var tpl = new Template();

        tpl.assign('globals', this.globals.toArray());
        tpl.assign('enableAssert', options.assert);
        tpl.assign('platform', options.platform);

        // wrap with application and merge

        var fw, tmpNode;

        if (options['no-framework'] === false) {
            node.add('(function() {\n');
        }

        // nostrict tweak

        if (options['tweak-nostrict'] !== true) {
            node.add('"use strict";\n');
        }

        if (options['no-framework'] === false) {

            fw = tpl.fetch(resource('../../templates/adria/framework.tpl'));
            tmpNode = node.add(new SourceNode(1, 0, 'adria-framework.js', fw));
            tmpNode.setSourceContent('adria-framework.js', fw);

            // merge resources

            for (var fileName in this.resources.data) {
                var contents = fs.readFileSync(options.basePath + fileName, 'UTF-8');
                var wrapped = 'resource(\'' + fileName + '\', \'' + contents.jsify("'") + '\');\n';
                tmpNode = node.add(new SourceNode(null, null, fileName, wrapped));
                tmpNode.setSourceContent(fileName, contents);
            }
        }

        // merge modules

        for (var id, module in this.modules) {
            tmpNode = node.add(new SourceNode(null, null, module.filename, module.result));
            tmpNode.setSourceContent(module.filename, module.sourceCode);
        }

        if (options['no-framework'] === false) {
            node.add('\n})();');
        }

        return node;
    },

    /**
     * entry point, run transformation
     */
    run: function() {

        // create a prototype parser to clone from (to avoid training overhead)

        this.protoParser = new AdriaParser(this);
        this.protoParser.trainSelf();

        // process piped data and initial files

        if (this.piped !== undefined) {
            this.buildModule('main' + this.options.fileExt, this.piped);
        }

        var files = this.options.files;

        for (var id in files) {
            this.buildModule(util.normalizeExtension(files[id], this.options.fileExt));
        }

        // result

        var node = this.generateOutputTree();
        var options = this.options;

        if (options.outFile !== null) {

            var jsFile = options.basePath + options.outFile;
            var mapFile = jsFile.stripPostfix('.js') + '.map';

            if (options['no-map'] !== true) {

                var result = node.toStringWithSourceMap({ file: options.outFile });
                var mapLink = '\n//@ sourceMappingURL=' + path.relative(options.basePath, mapFile);

                fs.writeFileSync(jsFile, result.code + (options['no-link'] ? '' : mapLink));
                fs.writeFileSync(mapFile, result.map);

            } else {

                var result = node.toString();
                fs.writeFileSync(jsFile, options['no-blanks'] ? this.postProcess(result) : result);
            }

        } else {

            process.stdout.write(node.toString());
        }
    },

    postProcess: function(code) {

        // remove blank lines

        code = code.replace(/\n[\ \n]*\n/g, '\n');
        return code;
    },
};
