/*
 * Adria transcompiler
 *
 * Copyright (C) 2014 Dennis MÃ¶hlmann <mail@dennismoehlmann.de>
 * Licensed under the MIT license.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var fs = require('fs');
var path = require('path');
var util = require('../util');
var args = require('../args');
var Set = require('astd/set');
var SourceNode = require('source-map').SourceNode;
var Template = require('../template');
var Transform = require('../transform');
var AdriaParser = require('./adria_parser');

/**
 * Transforms a set of input files into one or more output files using the
 * Adria language transformation definition
 *
 * @see Transform
 */
module AdriaTransform = proto (Transform) {

    /**
     * populated by globals node, names of application-wide globals
     */
    cacheModifier   : null,
    globals         : null,
    implicits       : null,
    requires        : null,
    modules         : null,
    resources       : null,
    usedBuiltins    : null,
    requiresDone    : null,
    sourceCode      : null,
    protoParser     : null,

    builtins: {
        'async.adria': resource('../../templates/adria/async.tpl'),
    },

    constructor: func(piped) {

        Transform->constructor(piped);

        this.globals        = new Set();
        this.implicits      = new Set();
        this.requires       = new Set();
        this.resources      = new Set();
        this.requiresDone   = new Set();
        this.usedBuiltins   = new Set();
        this.modules        = [ ];
        this.sourceCode     = { };

        // implicitly known references

        this.defineImplicits();
    },

    initOptions: func() {

        Transform->initOptions(this);

        args.add(
            [ '-b', '--base' ],
            { help: 'Base path, include paths are relative to this', defaultValue: '', dest: 'basePath', metavar: '<path>', required: false }
        );

        args.add(
            [ '-p', '--path' ],
            { help: 'Additional path to look for includes', action: 'append', dest: 'paths', metavar: '<path>' }
        );

        args.add(
            [ '-o', '--out' ],
            { help: 'Output file', action: 'store', dest: 'outFile', metavar: '<file>' }
        );

        args.add(
            [ '--extension' ],
            { help: 'Adria file extension (adria)', defaultValue: 'adria', metavar: '<ext>', required: false },
            func(value) { return '.' + value; }
        );

        args.add(
            [ '-t', '--target' ],
            { help: 'Platform to generate code for (node)', action: 'store', choices: [ 'node', 'web' ], dest: 'platform', defaultValue: 'node' }
        );

        args.add(
            [ '--header'],
            { help: 'File to include as commentblock before output', action: 'store', dest: 'headerFile', defaultValue: '', metavar: '<file>' }
        );

        args.add(
            [ '-D', '--define' ],
            { help: 'Define preprocessor value, i.e. version="1.2"', metavar: '<key>=<value>', action: 'append', dest: 'defines' },
            func(data) {
                var result = { };
                for (var id, value in data) {
                    var pair = value.split('=');
                    result[pair[0]] = (pair[1] === undefined ? true : pair[1]);
                }
                return result;
            }
        );

        args.add(
            [ 'files' ],
            { help: 'File(s) to compile', nargs: '+' }
        );

        args.addSwitch('shellwrap', 'Wrap in shell-script and flag executable', false);
        args.addSwitch('application', 'Generate application global', true);
        args.addSwitch('map', 'Generate source map', false);
        args.addSwitch('link', 'Link sourcemap to output', true);
        args.addSwitch('blanks', 'Allow blank lines [to be removed]', true);
        args.addSwitch('strict', 'Compile strict Javascript', true);
        args.addSwitch('closure', 'Contain code in closure', true);
        args.addSwitch('assert', 'Add assert() support', false);
        args.addSwitch('scan', 'Perform basic logic checks', true);
    },

    processOptions: func() {

        parent->processOptions();
        this.cacheModifier = util.md5(JSON.stringify(this.options));
    },

    /**
     * defines implictly known references
     */
    defineImplicits: func() {

        this.implicits.add([
            'window',
            'arguments', 'this', 'true', 'false', 'null', 'undefined', 'Infinity', 'NaN',
            'Array', 'Boolean', 'Date', 'Intl', 'JSON', 'Function', 'Math', 'Number', 'Object', 'RegExp', 'String',
            'ArrayBuffer', 'DataView', 'Float32Array', 'Float64Array', 'Int16Array', 'Int32Array', 'Int8Array',
            'Uint16Array', 'Uint32Array', 'Uint8Array',
            'Error', 'EvalError', 'RangeError', 'ReferenceError', 'SyntaxError', 'TypeError', 'URIError',
            'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'eval',
            'setTimeout', 'clearTimeout', 'setInterval', 'clearInterval',
            'isFinite', 'isNaN', 'parseFloat', 'parseInt',
            'console', 'debugger',
            'application', 'Exception',
        ]);

        if (this.options['platform'] === 'node') {
            this.implicits.add([ 'process', 'Buffer' ]);
        } else if (this.options['platform'] === 'web') {
            this.implicits.add([ 'screen', 'document', 'location', 'performance', 'alert', 'XMLHttpRequest', 'Worker' ]);
        }

        if (this.options['assert']) {
            this.implicits.add('AssertionFailedException');
        }
    },

    /**
     * build a module and its dependencies recursively and push the
     * result onto AdriaTransform::modules
     *
     * @param moduleName name of the module
     * @param data module source code
     */
    buildModule: func(moduleName, data) {

        // create parser from proto-parser

        var parser = this.protoParser.clone();
        parser.moduleName = moduleName;

        if (data === undefined) {
            parser.loadSource(this.options['basePath'] + moduleName, this.cacheModifier);
        } else {
            parser.setSource(moduleName, data, this.cacheModifier);
        }

        // generate result

        parser.preprocess({ });
        var result = parser.output();

        // add globals and requires to transform

        var requires = parser.resultData.requires;

        this.requiresDone.add(moduleName);

        for (var name in requires.data) {
            if (this.requiresDone.has(name) === false) {
                this.buildModule(name);
            }
        }

        // these are used in the template

        this.requires = this.requires.merge(parser.resultData.requires);
        this.globals = this.globals.merge(parser.resultData.globals);
        this.resources = this.resources.merge(parser.resultData.resources);

        // push module after all dependencies have been resolved

        this.modules.push({ result: result, parser: parser });
    },

    /**
     * generate JavaScript SourceNode output tree from built modules
     */
    generateOutputTree: func() {

        var options = this.options;
        var node = new SourceNode(null, null);
        var tpl = new Template();

        tpl.debug = this.options['debug'];
        tpl.assign('globals', this.globals.toArray());
        tpl.assign('builtins', this.usedBuiltins.toArray());
        tpl.assign('enableAssert', options['assert']);
        tpl.assign('enableApplication', options['application']);
        tpl.assign('platform', options['platform']);

        // wrap in shellscript

        if (options['shellwrap']) {
            node.add([ '#!/bin/sh\n', '\':\' //; exec "`command -v nodejs || command -v node`" --harmony "$0" "$@"\n' ]);
        }

        // include header comment

        if (options['headerFile'] !== '') {
            var header = fs.readFileSync(options['basePath'] + options['headerFile'], 'UTF-8');
            node.add('/**\n * ' + header.trim().replace(/\r?\n/g, '\n * ') + '\n */\n');
        }

        // wrap with application and merge

        var fw, tmpNode;

        if (options['closure']) {
            node.add(';(function() {\n');
        }

        // apply strict mode

        if (options['strict']) {
            node.add('"use strict";\n');
        }

        fw = tpl.fetch(resource('../../templates/adria/framework.tpl'));
        tmpNode = node.add(new SourceNode(1, 0, 'adria-framework.js', fw));
        tmpNode.setSourceContent('adria-framework.js', fw);

        // merge resources

        for (var fileName in this.resources.data) {
            var contents = fs.readFileSync(options['basePath'] + fileName, 'UTF-8');
            var wrapped = 'resource(\'' + fileName + '\', \'' + contents.jsify("'") + '\');\n';
            tmpNode = node.add(new SourceNode(null, null, fileName, wrapped));
            tmpNode.setSourceContent(fileName, contents);
        }

        // merge builtins

        var usedBuiltins = this.usedBuiltins.toArray();

        for (var id, name in usedBuiltins) {
            fw = tpl.fetch(this.builtins[name]);
            tmpNode = node.add(new SourceNode(1, 0, name.replace('.adria', '.js'), fw));
            tmpNode.setSourceContent(name.replace('.adria', '.js'), fw);
        }

        // merge modules

        for (var id, currentModule in this.modules) {
            tmpNode = node.add(new SourceNode(null, null, currentModule.parser.file, currentModule.result));
            tmpNode.setSourceContent(currentModule.parser.file, currentModule.parser.sourceCode);
        }

        // start builtins

        for (var id, name in usedBuiltins) {
            node.add('\n' + (options['platform'] === 'node' ? '___' : '') + 'require(\'' + name + '\');');
        }

        // start entry module

        for (var id, file in options['files']) {
            node.add('\n' + (options['platform'] === 'node' ? '___' : '') + 'require(\'' + util.normalizeExtension(file, this.options['extension']) + '\');');
        }

        if (options['closure']) {
            node.add('\n})();');
        }

        return node;
    },

    scan: func() {

        for (var id, currentModule in this.modules) {
            currentModule.parser.scan({ });
        }
    },

    /**
     * entry point, run transformation
     */
    run: func() {

        // create a prototype parser to clone from (to avoid training overhead)

        this.protoParser = new AdriaParser(this);
        this.protoParser.trainSelf();

        // process piped data and initial files

        if (this.piped !== undefined) {
            this.buildModule('main' + this.options['extension'], this.piped);
        }

        var files = this.options['files'];

        for (var id in files) {
            this.buildModule(util.normalizeExtension(files[id], this.options['extension']));
        }

        // scan modules for undefined variables

        if (this.options['scan']) {
            this.scan();
        }

        // result

        var node = this.generateOutputTree();
        var options = this.options;

        if (options['outFile'] !== null) {

            var jsFile = options['basePath'] + options['outFile'];
            var mapFile = jsFile.stripPostfix('.js') + '.map';

            if (options['map']) {

                var result = node.toStringWithSourceMap({ file: options['outFile'] });
                var mapLink = '\n//@ sourceMappingURL=' + path.relative(options['basePath'], mapFile);

                fs.writeFileSync(jsFile, result.code + (options['link'] ? mapLink : ''));
                fs.writeFileSync(mapFile, result.map);

            } else {

                var result = node.toString();
                fs.writeFileSync(jsFile, options['blanks'] ? result : this.postProcess(result));
            }

            if (options['shellwrap']) {
                fs.chmodSync(jsFile, 493 /*0755*/);
            }

        } else {

            process.stdout.write(node.toString());
        }
    },

    postProcess: func(code) {

        // remove blank lines

        code = code.replace(/\n[\ \n]*\n/g, '\n');
        return code;
    },
};
