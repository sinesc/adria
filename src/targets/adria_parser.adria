/*
 * The MIT License (MIT)
 *
 * Copyright (C) 2013 Dennis Möhlmann <mail@dennismoehlmann.de>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var fs = require('fs');
var util = require('../util');
var LanguageParser = require('../language_parser');
var AdriaNode = require('./adria_node');
var Tokenizer = require('../tokenizer');

/**
 * LanguageParser subclass defining additional Adria specific .sdt-file
 * entities and setting up blockname to class mappings.
 */
module AdriaParser = proto(LanguageParser) {

    moduleName: '',
    indent: 0,
    resultData: null,

    constructor: function(transform) {

        LanguageParser->constructor(transform);

        this.resultData = {
            globals: new util.Set(),
            requires: new util.Set(),
            resources: new util.Set(),
        };
    },

    /**
     * initialize a tokenizer, load definition files into a trainer and call parent's trainself, which
     * will use the trainer to genererate the definition for this parser
     */
    trainSelf: function() {

        var keywords = new util.Set([
            'var', 'global',
            'if', 'else',
            'for', 'in', 'do', 'while', 'break', 'continue',
            'switch', 'case',
            'throw', 'try', 'catch', 'finally',
            'function', 'proto', 'property', 'parent', 'yield', 'await',
            'require', 'assert', 'resource',
            'delete', 'new',
            'instanceof', 'typeof'
        ]);

        var matchKeywords = function(match) {

            if (keywords.has(match.data)) {
                match.name = 'KEYWORD';
            }
            return match;
        };

        this.tokenizer = new Tokenizer([
            Tokenizer.prefab.delimited(null, '/*', '*/'),
            Tokenizer.prefab.regex(null, /^\/\/.*/),
            Tokenizer.prefab.breaker(),
            Tokenizer.prefab.regex('REGEXP', /^\/(?:(?=(\\?))\1.)*?\/[a-z]*/, /^(\(|=|==|===|\+|!=|!==|,|;|\:)$/),
            Tokenizer.prefab.set('DELIM', [ ';', '.', ',', '(', ')', '[', ']', '{', '}', '!==', '!=', '!', '++', '--', '#' ]),
            Tokenizer.prefab.group('DELIM', [ '=', '&', '|', '<', '>', ':', '?', '+', '-', '*', '/', '%' ]),
            Tokenizer.prefab.regex('IDENT', /^[a-zA-Z_\$][a-zA-Z0-9_\$]*/, null, matchKeywords),
            Tokenizer.prefab.number('NUMERIC'),
            Tokenizer.prefab.regex('STRING', /^(["'])(?:(?=(\\?))\2[\s\S])*?\1/),
        ], [ 'KEYWORD' ]);

        util.log('AdriaParser', 'trainer processing adria .sdt-files', 2);
        this.setDefinition(resource('../../definition/adria/control.sdt'), 'control');
        this.setDefinition(resource('../../definition/adria/expression.sdt'), 'expression');
        this.setDefinition(resource('../../definition/adria/literal.sdt'), 'literal');
        this.setDefinition(resource('../../definition/adria/proto.sdt'), 'proto');
        this.setDefinition(resource('../../definition/adria/root.sdt'), 'root');
        this.setDefinition(resource('../../definition/adria/statement.sdt'), 'statement');

        util.log('AdriaParser', 'being trained', -2);
        LanguageParser->trainSelf();
        util.log('AdriaParser', 'done');
    },

    /**
     * maps capture_names to subclasses of CaptureNode
     *
     * @param string captureName node capture name (unused at the moment)
     * @param string blockName name of the block containing the node (mapped to classname)
     */
    mapType: function(captureName, blockName) {

        var typeName = blockName.snakeToCamel(true);

        if (typeof AdriaNode[typeName] === 'function') {
            return AdriaNode[typeName];
        }

        return AdriaNode;
    },

    /**
     * add definition file support for ident, name and regex tag
     *
     * @return Parser.Definition.Node
     */
    createNode: function(name, capture, label, condition) {

        var node = LanguageParser.prototype.createNode.call(this, name, capture, label, condition);

        if (name === 'ident') {

            node.match          = '';
            node.type           = 0;
            node.tokenType      = this.tokenizer.Type.IDENT;
            node.description    = 'identifier';

        } else if (name === 'name') {

            node.match          = '';
            node.type           = 0;
            node.tokenType      = this.tokenizer.Type.IDENT | this.tokenizer.Type.KEYWORD;
            node.description    = 'name';

        } else if (name === 'regexp') {

            node.match          = '';
            node.type           = 0;
            node.tokenType      = this.tokenizer.Type.REGEXP;
            node.description    = 'regexp';
        }

        return node;
    },

    /**
     * change loadSourceFromCache behaviour to also load the original source,
     * if source-mapping is enabled
     *
     * @see LanguageParser::loadSourceFromCache
     */
    loadSourceFromCache: function(filename) {

        LanguageParser.prototype.loadSourceFromCache.call(this, filename);

        if (this.cacheData !== null && this.transform.options['no-map'] !== true) {
            this.sourceCode = fs.readFileSync(filename, 'UTF-8').replace('\r\n', '\n');
        }
    },
};
