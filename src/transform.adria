/*
 * Adria transcompiler
 *
 * Copyright (C) 2014 Dennis MÃ¶hlmann <mail@dennismoehlmann.de>
 * Licensed under the MIT license.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var fs = require('fs');
var Cache = require('./cache');
var util = require('./util');

/**
 * Base for language transformation file handling. Transforms a set of input
 * files into one or more output files using given options.
 */
module Transform = proto {

    /**
     * @var Array command line options
     */
    options: null,

    /**
     * @var string option file to load command line options from
     */
    readOptionFile: null,

    /**
     * @var string option file to write command line options to
     */
    writeOptionFile: null,

    /**
     * @var string? data received via stdin
     */
    stdin: null,

    /**
     * @var Cache output cache
     */
    cache: null,

    /**
     * @var integer short unique id
     */
    uid: 1,

    /**
     * constructor
     *
     * @param string data received via stdin
     */
    constructor: func(string? stdin = null) {

        this.stdin = stdin;

        this.initOptions();
        this.processOptions();

        if (this.options['cache']) {
            this.cache = new Cache();
        }
    },

    /**
     * reset transform object
     */
    reset: func() {
        this.uid = 1;
    },

    /**
     * initialize options definition, extend with own options
     */
    initOptions: func() {

        application.args.addSwitch('cache', 'Cache generated code', true);

        // handle option file now because the specific transform might add required options

        application.args.add(
            [ '-c', '--config' ],
            { help: 'Use build configuration', dest: 'readConfig', metavar: '<file>', defaultValue: '*', nargs: '?' },
            func(value) { return value === '*' ? null : (value === null ? 'build.abc' : util.normalizeExtension(value, '.abc')); }
        );

        application.args.add(
            [ '--write-config' ],
            { help: 'Write build configuration', dest: 'writeConfig', metavar: '<file>', defaultValue: '*', nargs: '?' },
            func(value) { return value === '*' ? null : (value === null ? 'build.abc' : util.normalizeExtension(value, '.abc')); }
        );

        var options = application.args.parseKnown();
        this.readOptionFile = options['readConfig'];
        this.writeOptionFile = options['writeConfig'];
    },

    /**
     * either load or save options from file or processes given command-line arguments
     */
    processOptions: func() {

        if (this.readOptionFile !== null) {
            this.options = JSON.parse(fs.readFileSync(this.readOptionFile));
        } else {
            this.options = application.args.parseAll();
        }

        delete this.options['readConfig'];
        delete this.options['writeConfig'];

        if (this.writeOptionFile !== null) {
            fs.writeFileSync(this.writeOptionFile, JSON.stringify(this.options, null, '\t'));
        }
    },

    /**
     * returns continuously increasing unique id
     *
     * @return integer
     */
    makeUID: func() {
        return (this.uid++).toString(36);
    },

    /**
     * entry point, run transformation
     */
    run: func() { },
};
