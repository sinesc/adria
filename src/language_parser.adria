/*
 * The MIT License (MIT)
 *
 * Copyright (C) 2013 Dennis Möhlmann <mail@dennismoehlmann.de>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var fs = require('fs');
var util = require('./util');
var Parser = require('./parser');
var DefinitionParser = require('./definition_parser');
var CaptureNode = require('./language_parser/capture_node');

/**
 * Parser subclass with the capability to use a secondary DefinitionParser to train itself from .sdt-files. Defines
 * defintion fiel entities entry, return, string, numeric as well as literal match (i.e. "matchme") and definition jumps
 * (by using the name of a definition as match component)
 * Also provides CaptureNode baseclass to convert parser captures into an object tree of userdefined node-types.
 */
module LanguageParser = proto(Parser) {

    /**
     * @var DefinitionParser trainer secondary parser that will be used to train this one
     */
    trainer: null,

    /**
     * @var String input file
     */
    sourceCode: null,

    /**
     * @var CaptureNode captureTree contains capture result tree after file parsing
     */
    captureTree: null,

    /**
     * @var Object extra data accumulated during parsing
     */
    resultData: null,

    /**
     * @var Object cache file metadata
     */
    cacheData: null,

    /**
     * @var String method used for output generation
     */
    outputMethod: 'toSourceNode',

    /**
     * construct new instance
     *
     * @param transform the applications transform object
     */
    constructor: function(transform) {

        Parser->constructor(transform);

        this.transform = transform;
        this.resultData = { };
    },

    /**
     * constructs new instance referencing source's definition and
     * transform link
     */
    clone: function() {

        var parser = Parser->clone();
        parser.transform = this.transform;
        parser.source = this.source;
        return parser;
    },

    /**
     * reset definition, then train this parser with currently loaded .sdt-file definitions
     * this is done using the integrate_node_pair() and createNode() methods
     */
    trainSelf: function() {

        assert(this.trainer != null);

        this.definition = new Parser.Definition();
        this.trainer.trainOther(this);
        this.trainer = null;
    },

    /**
     * set definition from string
     *
     * @param string data definition string
     * @param string filename name (display purpose only)
     */
    setDefinition: function(data, filename) {

        util.log('LanguageParser', 'setting definition file ' + filename);

        // feed file contents to secondary parser

        if (this.trainer == null) {
            this.trainer = new DefinitionParser();
        }

        util.log('LanguageParser', 'processing definition', 2);
        this.trainer.file = filename;
        this.trainer.parse(data);
        util.log('LanguageParser', 'done', -2);
    },

    /**
     * load definition
     *
     * @param string filename name
     */
    loadDefinition: function(filename) {

        util.log('LanguageParser', 'loading definition file ' + filename);

        var fileContents = fs.readFileSync(filename, 'UTF-8');

        this.setDefinition(fileContents, filename);
    },

    /**
     * called during capture list to tree conversion process to select an appropriate node-type
     */
    mapType: function(capture_name, block_name) {
        return CaptureNode;
    },

    /**
     * map a path node ("name:capture[label]?condition") to a new parser node. used by secondary DefinitionParser
     *
     * @param string name path node name part
     * @param string capture capture part
     * @param string label label part
     * @param string condition condition part
     * @return Parser.Definition.Node new definition node
     */
    createNode: function(name, capture, label, condition) {

        var Node = Parser.Definition.Node;
        var node = new Node();

        node.name       = name;
        node.capture    = capture;
        node.label      = label;
        node.condition  = condition;

        switch (name) {
            case 'entry':
            case 'return':
                node.match          = name; //!todo is this used somewhere somehow? it cannot be used as a match
                node.tokenType      = -1;
                node.type           = (name == 'entry' ? Node.Type.BLOCK : Node.Type.RETURN);
                node.description    = name;
                break;

            case 'string':
                node.match          = '';
                node.tokenType      = this.tokenizer.Type.STRING;
                node.type           = 0;
                node.description    = 'string';
                break;

            case 'numeric':
                node.match          = '';
                node.tokenType      = this.tokenizer.Type.NUMERIC;
                node.type           = 0;
                node.description    = 'numerical';
                break;

            default:
                var numChars = name.length;

                if (name[0] == '\"') {

                    // string match

                    assert(numChars >= 3);

                    node.match          = new RegExp('^' + RegExp.escape(name.slice(1, numChars -1)) + '$');
                    node.tokenType      = -1;
                    node.type           = 0;
                    node.description    = name.slice(1, numChars -1);

                } else if (name[0] == '\'') {

                    // regex match

                    assert(numChars >= 3);

                    node.match          = new RegExp(name.slice(1, numChars -1));
                    node.tokenType      = -1;
                    node.type           = 0;
                    node.description    = name.slice(1, numChars -1);

                } else {

                    // definition jump

                    node.match          = name;
                    node.tokenType      = -1;
                    node.type           = Node.Type.JUMP;
                    node.description    = 'definition jump';
                }

                break;
        }

        return node;
    },

    /**
     * integrate a pair of two nodes into the definition. used by secondary DefinitionParser
     *
     * @param pair
     * @param blockName
     */
    integrateNodePair: function(pair, blockName) {

        // connect both nodes of the pair (add return type nodes to the tail(!), others to the head)

        pair[0].add(pair[1], Parser.Definition.Node.Type.RETURN & pair[1].type);

        // append entry-node to definition (once only as it is already fully connected)

        if (pair[0].type == Parser.Definition.Node.Type.BLOCK && this.definition.haveBlock(blockName) == false) {

            this.definition.createBlock(blockName, pair[0]);
        }
    },

    /**
     * set source data and process it to a CaptureNode tree
     *
     * @param string filename name (for display)
     * @param string data contents
     */
    setSource: function(filename, data) {

        // load source file

        this.captureTree = null;
        this.file = filename;
        this.sourceCode = data.replace('\r\n', '\n');

        // parse file contents

        util.log('LanguageParser', 'processing source ' + filename, 2);
        var captures = this.parse(this.sourceCode);
        util.log('LanguageParser', 'done', -2);

        this.captureTree = CaptureNode::fromResults(captures, this.mapType.bind(this));
        this.captureTree.parent = this;
    },

    /**
     * try to load sourcefile from cache
     *
     * @param filename
     */
    loadSourceFromCache: function(filename) {

        this.cacheData = this.transform.cache.fetch(filename, [ 'base'/*, 'resultData'*/ ]);

        if (this.cacheData !== null) {
            this.file = filename;
            this.captureTree = CaptureNode::fromJSON(this.cacheData['base'], this, this.mapType.bind(this));
            //this.resultData = this.unserializeData(this.cacheData['resultData']);
        }
    },

    /**
     * load source file and process it to a CaptureNode tree
     *
     * @param string filename name
     */
    loadSource: function(filename) {

        // try to load from cache

        if (this.transform.options['no-cache'] !== true && this.cacheData === null) {
            this.loadSourceFromCache(filename);
        }

        // check if now available from cache, if not, parse

        if (this.cacheData === null) {
            this.setSource(filename, fs.readFileSync(filename, 'UTF-8'));
        }
    },

    /**
     * runs scan on the capture tree
     *
     * @param state userdefined scan state object passed to every node
     */
    scan: function(state) {

        var InitialType = this.mapType('', this.definition.initialBlock);
        InitialType::scan.call(this.captureTree, state);
    },

    /**
     * runs preprocess on the capture tree
     *
     * @param state userdefined preprocess state object passed to every node
     */
    preprocess: function(state) {

        var InitialType = this.mapType('', this.definition.initialBlock);
        InitialType::preprocess.call(this.captureTree, state);
    },

    /**
     * process the parse captures into output format
     *
     * @return string output string
     */
    output: function() {

        var result;

        // generate result

        var InitialType = this.mapType('', this.definition.initialBlock);
        result = InitialType.prototype[this.outputMethod].call(this.captureTree);

        // write new data to cache (don't write it again if it just came from the cache)

        if (this.transform.options['no-cache'] !== true && this.cacheData === null && fs.existsSync(this.file)) {

            this.transform.cache.insert(this.file, {
                base        : this.captureTree.toJSON(),
                //resultData  : this.serializeData(this.resultData)
            });
        }

        return result;
    },
};

CaptureNode.LanguageParser = LanguageParser; //!ugly, find better way to avoid circular require
LanguageParser.CaptureNode = CaptureNode;
