/*
 * Adria transcompiler
 *
 * Copyright (C) 2014 Dennis MÃ¶hlmann <mail@dennismoehlmann.de>
 * Licensed under the MIT license.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * provides a base clone method, returning a new object of this type without
 * calling the constructor. Chain to this method, then copy properties to the
 * result object as required
 *
 * @return object
 */
Object::clone = prop {
    value: func() {
        return Object.create(Object.getPrototypeOf(this));
    },
    writable: true,
};

/**
 * convert snake-cast to camel-case, i.e. test_function to testFunction or TestFunction
 *
 * @param upperFirst if true, uppercase first letter as well
 * @return string
 */
String::snakeToCamel = (func() {

    var firstToUpper = func(match1) {
        return match1.replace('_', '').toUpperCase();
    };

    return function snakeToCamel(upperFirst) {

        if (upperFirst) {
            return this.replace(/((?:^|\_)[a-z])/g, firstToUpper);
        } else {
            return this.replace(/(\_[a-z])/g, firstToUpper);
        }
    };

})();

/**
 * escapes string for use in javascript source code
 *
 * @param mode either " or ', if neither, string will be escaped for both cases
 * @return escapedString
 */
String::jsify = func(quoteType) {

    if (quoteType === "'") {
        return this.replace(/([\\'])/g, "\\$1").replace(/\r?\n/g, '\\n\\\n').replace(/\0/g, "\\0");
    } else if (quoteType === '"') {
        return this.replace(/([\\"])/g, "\\$1").replace(/\r?\n/g, '\\n\\\n').replace(/\0/g, "\\0");
    } else {
        return this.replace(/([\\"'])/g, "\\$1").replace(/\r?\n/g, '\\n\\\n').replace(/\0/g, "\\0");
    }
};

/**
 * formats this string with given arguments
 * !todo used just once, either refactore more code to use or drop it. first case: update from astdlib
 */
String::format = func() {

    var args = Array::slice.call(arguments);

    // if first argument is array or object, use only that

    if (args.length === 1 && args[0] instanceof Object) {
        args = args[0];
    }

    return this.replace(/(.?)\$([0-9a-z]+)(\:[0-9a-z]+)?/ig, func(str, prefix, matchname, options) {

        // double $$ means to output a $ instead of a formatstring

        if (prefix == '$') {
            return '$' + matchname + (options !== undefined ? options : '');
        }

        //!todo use of options

        return (args[matchname] !== undefined ? prefix + args[matchname] : str);
    });
};

/**
 * repeats this string count times and returns the result
 *
 * @param count
 * @return repeatedString
 */
String::repeat = func(count) {

    if (count < 1) {
        return '';
    }

    var result = '';
    var pattern = this.valueOf();

    while (count > 1) {

        // append every time a 1 would be shifted out

        if (count & 1) {
            result += pattern;
        }

        // double pattern length, halv count, next rest now in bit 1

        count >>= 1;
        pattern += pattern;
    }

    // unrolled from count > 0

    result += pattern;

    return result;
};

/**
 * repeats the given string count times and returns the result
 *
 * @param count
 * @param string
 * @return repeatedString
 */
String.repeat = func(count, string) {

    string = (string === undefined ? ' ' : string);
    return string.repeat(count);
};

/**
 * returns number of occurances of a given search string in this string
 *
 * @param search
 * @return count
 */
String::occurances = func(search) {

    var count = 0;
    var index = this.indexOf(search);

    while (index !== -1) {
        count++;
        index = this.indexOf(search, index + 1);
    }

    return count;
};

/**
 * starting from the left, pads the string to paddedLength using given padChar
 *
 * @param paddedLength
 * @param padChar
 * @return paddedString
 */
String::padLeft = func(paddedLength, padChar) {

    padChar = (padChar !== undefined ? padChar : ' ');
    return padChar.repeat(paddedLength - this.length) + this.valueOf();
};

/**
 * returns a random string of given length composed of given chars
 *
 * @param length
 * @param chars
 * @return randomString
 */
String.random = func(length, chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') {

    var numChars    = chars.length;
    var result      = '';

    for (var i = 0; i < length; i++) {
        var rnum = Math.floor(Math.random() * numChars);
        result += chars.substr(rnum, 1);
    }

    return result;
};

/**
 * removes given postfix or one of an array of postfixes from a string and
 * returns the new string
 *
 * @param postfix string or array of strings
 * @return strippedString
 */
String::stripPostfix = func(postfix) {

    var len;

    if (postfix instanceof Array) {

        for (var i in postfix) {

            len = postfix[i].length;

            if (this.substr(-len) === postfix[i]) {
                return this.substr(0, this.length - len);
            }
        }

        return this.valueOf();
    }

    len = postfix.length;
    return (this.substr(-len) === postfix ? this.substr(0, this.length - len) : this.valueOf());
};

/**
 * returns whether this string has given postfix
 *
 * @param postfix
 * @return bool
 */
String::hasPostfix = func(postfix) {

    return (this.substr(-postfix.length) === postfix);
};

/**
 * escape given string for use as literal regexp match
 *
 * @param string
 * @return escapedString
 */
RegExp.escape = func(string) {

    return string.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
};
