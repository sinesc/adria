/*
 * The MIT License (MIT)
 *
 * Copyright (C) 2013 Dennis MÃ¶hlmann <mail@dennismoehlmann.de>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var assert = require('assert');
var SourceNode = require('source-map').SourceNode;
var Template = require('../template');

/**
 * An abstract syntax node generated by CaptureNode.fromResults()
 */
var CaptureNode = function(key, value) {

    this.parent     = null;
    this.children   = null;
    this.key        = key;
    this.value      = value;

    this.tpl        = null;
    this.row        = 0;
    this.col        = 0;
};

/**
 * typename, required since current approach does not set constructor.name. this will change with self-hosting and have to be refactored then
 */
CaptureNode.prototype.typeName = 'CaptureNode';

/**
 * dummy returned by some functions as a convenience
 */
CaptureNode.prototype.dummy = new CaptureNode('', '');
CaptureNode.prototype.dummy.row = -1;
CaptureNode.prototype.dummy.col = -1;

/**
 * convert to JSON, loses parent
 */
CaptureNode.prototype.toJSON = function() {

    // recursively include all children

    var children = [];

    for (var id in this.children) {
        children.push(this.children[id].toJSON());
    }

    // try to keep it small

    return {
        _: this.typeName,
        s: children,
        k: this.key,
        v: this.value,
        t: this.tpl,
        r: this.row,
        c: this.col
    };
};

/**
 * create from JSON, restores parent
 */
CaptureNode.fromJSON = function(json, parent, typeMapper) {

    var Type = typeMapper(null, json._);
    
    var result = new Type(json.k, json.v);
    result.parent = parent;
    result.tpl = json.t;
    result.row = json.r;
    result.col = json.c;
    result.children = [ ];

    var jsonChildren = json.s;
    var resultChildren = result.children;

    for (var id in jsonChildren) {
        resultChildren.push(CaptureNode.fromJSON(jsonChildren[id], result, typeMapper));
    }

    return result;
};


/**
 * compares two stacks and returns number of parent-acends and list of capture desends to get from
 * lastStack to stack
 *
 * @param stack current stack
 * @param lastStack stack at last processed token
 * @param minStackLen the minimum size the stack had between the tokens for stack and lastStack
 */
var stackDiff = function(stack, lastStack, minStackLen) {

    // find deepest capture node that is present in both current and last stack

    var deepestCommonCapture = -1;
    var minLen = Math.min(stack.length, lastStack.length, minStackLen);

    for (var i = 0; i < minLen; i++) {
        if (stack[i].node === lastStack[i].node) {
            if (stack[i].node.capture !== '') {
                deepestCommonCapture = i;
            }
        } else {
            break;
        }
    }

    // find number of captures between deepest common capture and deepest previous capture
    // this is the number of nodes fromResults() needs to ascend before attaching new capture nodes

    var numCaptures = 0;
    var lastLen = lastStack.length;

    for (var i = deepestCommonCapture + 1; i < lastLen; i++) {
        if (lastStack[i].node.capture !== '') {
            numCaptures++;
        }
    }

    // find all capture nodes below the deepest common capture
    // fromResults() will have to create capture nodes for these

    var captures = [];
    var len = stack.length;

    for (var i = deepestCommonCapture + 1; i < len; i++) {
        if (stack[i].node.capture !== '') {
            captures.push(stack[i].node);
        }
    }

    return { ascend: numCaptures, create: captures };
};

/**
 * converts parser results to syntax tree structure
 *
 * @param results array of GeneratorState
 * @return CaptureNode root node of the capture tree
 */
CaptureNode.fromResults = function(results, typeMapper) {

    var root = new CaptureNode();
    var current = root;
    var lastStack = [];
    var result, stack, diff, node;

    // process each result

    for (var resultId in results) {
        result = results[resultId];
        stack = result.stack;

        // diff stack against previous stack

        diff = stackDiff(stack, lastStack, result.minStack);

        // ascend as far as required

        while (diff.ascend--) {
            current = current.parent;
        }

        // attach new nodes

        for (var nodeId in diff.create) {
            node = diff.create[nodeId];
            current = current.addNew(node.capture, node.name, typeMapper(node.capture, node.name));
            current.row = result.token.pos.row;
            current.col = result.token.pos.col;
        }

        // attach the actual match

        node = result.node;

        if (node.capture !== '') {
            var match = current.addNew(node.capture, result.token.data, typeMapper(node.capture, node.name));
            match.row = result.token.pos.row;
            match.col = result.token.pos.col;
        }

        // lastStack for the next token

        lastStack = stack;
    }

    return root;
};

CaptureNode.prototype.isNode = function() {
    return this.col !== -1;
};

CaptureNode.prototype.isLeaf = function() {
    return (this.children instanceof Array === false);
};

CaptureNode.prototype.isBranch = function() {
    return (this.children instanceof Array);
};

CaptureNode.prototype.length = function() {
    return (this.children instanceof Array ? this.children.length : 0);
};

/**
 * returns number of parents above node
 *
 * @return int depth
 */
CaptureNode.prototype.depth = function() {

    var result = 0;
    var current = this;

    while (current.parent instanceof CaptureNode) {

        result += 1;
        current = current.parent;
    }

    return result;
};

/**
 * returns ancestor with matching key and/or value
 *
 * @return CaptureNode or null
 */
CaptureNode.prototype.ancestor = function(key, value) {

    var current = this;

    key = (typeof key !== 'string' ? null : key.split('|')); //!todo use an array as parameter...
    value = (typeof value !== 'string' ? null : value.split('|'));

    if (key !== null && value !== null) {
        while (current.parent instanceof CaptureNode && key.indexOf(current.parent.key) === -1 && value.indexOf(current.parent.value) === -1) {
            current = current.parent;
        }
    } else if (key !== null) {
        while (current.parent instanceof CaptureNode && key.indexOf(current.parent.key) === -1) {
            current = current.parent;
        }
    } else if (value !== null) {
        while (current.parent instanceof CaptureNode && value.indexOf(current.parent.value) === -1) {
            current = current.parent;
        }
    }

    if (current.parent instanceof CaptureNode) {
        return current.parent;
    } else {
        return null;
    }
};

/**
 * returns the LanguageParser object owning this node
 *
 * @return LanguageParser or null
 */
CaptureNode.prototype.parser = function() {

    var current = this;

    while (current.parent !== null && (current.parent instanceof CaptureNode.LanguageParser === false)) {
        current = current.parent;
    }

    return current.parent;
};

/**
 * adds given stringnode to this node
 *
 * @param StringNode child new node to add
 * @return StringNode given StringNode
 */
CaptureNode.prototype.add = function(child) {

    if (this.children == null) {
        this.children = [ ];
    }

    this.children.push(child);
    return child;
};

/**
 * get the <index>th node that matches key with index = 0 being the first node
 *
 * @param string key node key to find
 * @param int index which of multiple key-matching nodes
 * @return CaptureNode or null
 */
CaptureNode.prototype.get = function(key, index, dummy) {

    index = (index === undefined ? 0 : index);
    dummy = (dummy === undefined ? this.dummy : null);

    if (this.children instanceof Array) {

        for (var id in this.children) {
            var child = this.children[id];

            if (child.key == key && index-- == 0) {
                return child;
            }
        }
    }

    return dummy;
};

/**
 * chains multiple get calls from input path, split by ., id indicated in array notation
 * i.e. this.path('value.function[3].body')
 *
 * @return CaptureNode or null
 */
CaptureNode.prototype.path = function(path, dummy) {

    var step;
    var current = this;

    dummy = (dummy === undefined ? this.dummy : null);
    path = path.split('.');

    for (var id in path) {
        step = path[id].split('[');

        if (step.length === 1) {
            current = current.get(step[0]);
        } else {
            current = current.get(step[0], parseInt(step[1].slice(0, -1)));
        }

        if (current === null) {
            return dummy;
        }
    }

    return current;
};

/**
 * creates and adds a stringnode of given subclass to this node
 *
 * @param string? key node key
 * @param string? value node value
 * @param Type node_type type of the newly created and added node. must be subtype of StringNode
 * @return StringNode the newly created StringNode
 */
CaptureNode.prototype.addNew = function(key, value, Type) {

    var child = new Type(key, value);

    assert(child != null);

    child.parent = this;

    return this.add(child);
};

/**
 * returns a newline and optionally increases or decreases indentation for the following lines
 *
 * @param indent change in indentation
 */
CaptureNode.prototype.nl = function(indent) {

    indent = (indent === undefined ? 0 : indent);

    var parser = this.parser();
    parser.indent += indent;
    return '\n' + String.repeat(parser.indent * 4, ' ');
};

/**
 * creates and returns a new sourcenode based on CaptureNode's position and given code
 *
 * @param code
 */
CaptureNode.prototype.csn = function(code) {

    return new SourceNode(this.row, this.col -1, this.parser().file, code); //!todo why is everthing offset by one if I don't subtract 1 here? col start at 0, row at 1? unlikely
};

/**
 * default node to string handler, returns empty string but calls children recursively
 *
 * @return string
 */
CaptureNode.prototype.toString = function() {

    var result = '';

    if (this.children instanceof Array) {
        for (var id in this.children) {
            result += this.children[id].toString();
        }
    }

    return result;
};

/**
 * default node to source-node handler, returns empty node but calls children recursively
 *
 * @return string
 */
CaptureNode.prototype.toSourceNode = function() {

    var result = new SourceNode(null, null);

    if (this.children instanceof Array) {
        for (var id in this.children) {
            result.add(this.children[id].toSourceNode());
        }
    }

    return result;
};

/**
 * exports immediate node-children to array of strings
 *
 * @param bool include_leafs include leaf nodes
 * @param bool include_branches include branch nodes
 * @param bool return_keys export node keys instead of node values to array
 * @return array of string
 */
 /*
CaptureNode.prototype.toArray = function(include_leafs, include_branches, return_keys) {

    include_leafs       = (include_leafs === undefined ? true : include_leafs);
    include_branches    = (include_branches === undefined ? false : include_branches);
    return_keys         = (return_keys === undefined ? false : return_keys);

    var result = [ ];

    if (this.isBranch()) {

        for (var id in this.children) {
            var child = this.children[id];

            if ((include_leafs && child.isLeaf()) || (include_branches && child.isBranch())) {

                if (return_keys !== true) {
                    result.push(child.value);
                } else {
                    result.push(child.key);
                }
            }
        }
    }

    return result;
};
*/

/**
 * runs toString on all siblings of this node (nodes that share the same parent and key)
 *
 * @return array of strings
 */
 /*
CaptureNode.prototype.siblingsToString = function() {

    assert(this.parent instanceof CaptureNode && this.parent.children instanceof Array);

    var result = [ ];
    var siblings = this.parent.children;

    for (var id in siblings) {
        var sibling = siblings[id];

        if (sibling.key === this.key) {
            result.push(sibling.toString());
        }
    }

    return result;
};
*/

/**
 * iterate over all childnodes
 *
 * @param NodeCallback function(node, first, last)
 */
CaptureNode.prototype.each = function(fn) {

    var children = this.children;

    if (children instanceof Array) {

        var last = children.length -1;

        for (var id in children) {
            fn.call(this, children[id], +id === 0, +id === last);
        }
    }
};

/**
 * iterate over all childnodes with given key
 *
 * @param string key node key
 * @param NodeCallback function(node, first, last)
 */
CaptureNode.prototype.eachKey = function(key, fn) {

    var part = key.split('.');

    if (this.children instanceof Array) {

        var children = this.children;
        var len = children.length;
        var prevChild = null;
        var first = true;
        var id;

        for (id = 0; id < len; id++) {
            var child = children[id];

            if (child.key === part[0]) {
                if (part.length === 1) {

                    // delay by one loop to be able to identify the last item

                    if (prevChild !== null) {
                        fn.call(this, prevChild, first, false);
                        first = false;
                    }

                    prevChild = child;

                } else if (part.length > 1) {
                    child.eachKey(part.slice(1).join('.'), fn);
                }
            }
        }

        // last item

        if (prevChild.key === part[0] && part.length === 1) {
            fn.call(this, prevChild, false, true);
        }
    }
};

/**
 * initialize a template object for this node and set the file to be used during tplGenerate()
 *
 * @param string fileName
 */
CaptureNode.prototype.setTemplate = function(fileName) {

    this.tpl = new Template();
    this.tplFile = fileName;
};

/**
 * returns generated template string for previously selected template file and assigned values
 *
 * @return string generated template string
 */
CaptureNode.prototype.processTemplate = function() {

    assert(this.tpl instanceof Template);

    return this.tpl.fetchFile(this.tplFile);
};

/**
 * assigns a value to the current template
 *
 * @param string uri qualified variable name
 * @param any value
 */
CaptureNode.prototype.assign = function(uri, value) {

    this.tpl.assign(uri, value);  //!todo assign to uri like target
};

/**
 * scan for symbol definitions
 *
 * @param LanguageParser owner the parser containing this node
 * @param Transform.Scope scope the current scope, initially this.transform.root_scope .
 *          scope generating nodes should instantiate a "new Transform.Scope(scope)" and pass it on to their child-nodes
 * @param int pass how often this function was called before with symbols still unresolved
 * @return int number of unresolved symbols
 */
CaptureNode.prototype.scanSymbols = function(owner, scope) {

    var result = 0;

    if (this.children instanceof Array) {
        for (var id in this.children) {
            result += this.children[id].scanSymbols(owner, scope);
        }
    }

    return result;
};

/*
 * export
 */
module.exports = CaptureNode;