/*
 * Adria transcompiler
 *
 * Copyright (C) 2014 Dennis MÃ¶hlmann <mail@dennismoehlmann.de>
 * Licensed under the MIT license.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var SourceNode = require('source-map').SourceNode;
var Template = require('../template');

/**
 * An abstract syntax node generated by CaptureNode::fromResults()
 */
module CaptureNode = proto {

    parent  : null,
    children: null,
    key     : '',
    value   : '',
    tpl     : null,
    row     : 0,
    col     : 0,

    /**
     * construct new capture node for given key/value
     *
     * @param key
     * @param value
     */
    constructor: func(key, value) {
        this.key    = key;
        this.value  = value;
    },

    /**
     * convert to JSON, loses parent
     */
    toJSON: func() {

        // recursively include all children

        var children = [];

        for (var id in this.children) {
            children.push(this.children[id].toJSON());
        }

        // try to keep it small

        return {
            _: this.constructor.name,
            s: children,
            k: this.key,
            v: this.value,
            t: this.tpl,
            r: this.row,
            c: this.col
        };
    },

    /**
     * static, create from JSON, restores parent
     */
    fromJSON: func(json, parentNode, typeMapper) {

        var Type = typeMapper(null, json._);

        var result = new Type(json.k, json.v);
        result.parent = parentNode;
        result.tpl = json.t;
        result.row = json.r;
        result.col = json.c;
        result.children = [ ];

        var jsonChildren = json.s;
        var resultChildren = result.children;

        for (var id in jsonChildren) {
            resultChildren.push(CaptureNode::fromJSON(jsonChildren[id], result, typeMapper));
        }

        return result;
    },

    /**
     * static, converts parser results to syntax tree structure
     *
     * @param results array of GeneratorState
     * @return CaptureNode root node of the capture tree
     */
    fromResults: (func() {

        /**
         * compares two stacks and returns number of parent-acends and list of capture desends to get from
         * lastStack to stack
         *
         * @param stack current stack
         * @param lastStack stack at last processed token
         * @param minStackLen the minimum size the stack had between the tokens for stack and lastStack
         */
        var stackDiff = func(stack, lastStack, minStackLen) {

            // find deepest capture node that is present in both current and last stack

            var deepestCommonCapture = -1;
            var minLen = Math.min(stack.length, lastStack.length, minStackLen);

            for (var i = 0; i < minLen; i++) {
                if (stack[i].node === lastStack[i].node) {
                    if (stack[i].node.capture !== '') {
                        deepestCommonCapture = i;
                    }
                } else {
                    break;
                }
            }

            // find number of captures between deepest common capture and deepest previous capture
            // this is the number of nodes fromResults() needs to ascend before attaching new capture nodes

            var numCaptures = 0;
            var lastLen = lastStack.length;

            for (var i = deepestCommonCapture + 1; i < lastLen; i++) {
                if (lastStack[i].node.capture !== '') {
                    numCaptures++;
                }
            }

            // find all capture nodes below the deepest common capture
            // fromResults() will have to create capture nodes for these

            var captures = [];
            var len = stack.length;

            for (var i = deepestCommonCapture + 1; i < len; i++) {
                if (stack[i].node.capture !== '') {
                    captures.push(stack[i].node);
                }
            }

            return { ascend: numCaptures, create: captures };
        };

        /**
         * the actual conversion function
         */
        return function fromResults(results, typeMapper) {

            var root = new CaptureNode();
            var current = root;
            var lastStack = [];
            var result, stack, diff, node;

            // process each result

            for (var resultId in results) {
                result = results[resultId];
                stack = result.stack;

                // diff stack against previous stack

                diff = stackDiff(stack, lastStack, result.minStack);

                // ascend as far as required

                while (diff.ascend--) {
                    current = current.parent;
                }

                // attach new nodes

                for (var nodeId in diff.create) {
                    node = diff.create[nodeId];
                    current = current.addNew(node.capture, node.name, typeMapper(node.capture, node.name));
                    current.row = result.token.pos.row;
                    current.col = result.token.pos.col;
                }

                // attach the actual match

                node = result.node;

                if (node.capture !== '') {
                    var match = current.addNew(node.capture, result.token.data, typeMapper(node.capture, node.name));
                    match.row = result.token.pos.row;
                    match.col = result.token.pos.col;
                }

                // lastStack for the next token

                lastStack = stack;
            }

            return root;
        };
    })(),

    isNode: func() {
        return this.col !== -1;
    },

    isDummy: func() {
        return this.col === -1;
    },

    isLeaf: func() {
        return (this.children instanceof Array === false);
    },

    isBranch: func() {
        return (this.children instanceof Array);
    },

    length: func() {
        return (this.children instanceof Array ? this.children.length : 0);
    },

    /**
     * returns number of parents above node
     *
     * @return int depth
     */
    depth: func() {

        var result = 0;
        var current = this;

        while (current.parent instanceof CaptureNode) {

            result += 1;
            current = current.parent;
        }

        return result;
    },

    /**
     * returns ancestor with matching key and/or value
     *
     * @param string/array key
     * @param string/array value
     * @param any dummy result when ancestor is not found
     * @return CaptureNode/dummy
     */
    ancestor: func(key, value = null, dummy = this.dummy) {

        var current = this;

        key = typeof key === 'string' ? [ key ] : key;
        value = typeof value === 'string' ? [ value ] : value;

        if (key !== null && value !== null) {
            while (current.parent instanceof CaptureNode && key.indexOf(current.parent.key) === -1 && value.indexOf(current.parent.value) === -1) {
                current = current.parent;
            }
        } else if (key !== null) {
            while (current.parent instanceof CaptureNode && key.indexOf(current.parent.key) === -1) {
                current = current.parent;
            }
        } else if (value !== null) {
            while (current.parent instanceof CaptureNode && value.indexOf(current.parent.value) === -1) {
                current = current.parent;
            }
        }

        if (current.parent instanceof CaptureNode) {
            return current.parent;
        } else {
            return dummy;
        }
    },

    /**
     * finds given constructor in ancestors
     *
     * @param function Constructor prototype constructor to find
     * @param boolean fromParent default true, will also check this if false
     * @param any dummy result when constructor is not found
     * @return CaptureNode/dummy
     */
    findProto: func(Constructor, fromParent = true, dummy = this.dummy) {

        var current = fromParent ? this.parent : this;

        while (current instanceof CaptureNode && current instanceof Constructor === false) {
            current = current.parent;
        }

        return current instanceof Constructor ? current : dummy;
    },

    /**
     * returns the LanguageParser object owning this node
     *
     * @return LanguageParser or null
     */
    parser: func() {

        var current = this;
        var LanguageParser = require('../language_parser');

        while (current.parent !== null && (current.parent instanceof LanguageParser === false)) {
            current = current.parent;
        }

        return current.parent;
    },

    /**
     * adds given CaptureNode to this node
     *
     * @param CaptureNode child new node to add
     * @return CaptureNode given CaptureNode
     */
    add: func(child) {

        if (this.children == null) {
            this.children = [ ];
        }

        this.children.push(child);
        return child;
    },

    /**
     * get the <index>th node that matches key with index = 0 being the first node
     *
     * @param string key node key to find
     * @param int index which of multiple key-matching nodes
     * @param any dummy result when ancestor is not found
     * @return CaptureNode/dummy
     */
    get: func(key, index = 0, dummy = this.dummy) {

        if (this.children instanceof Array) {

            for (var id in this.children) {
                var child = this.children[id];

                if (child.key == key && index-- == 0) {
                    return child;
                }
            }
        }

        return dummy;
    },

    /**
     * chains multiple get calls from input path, split by ., id indicated in array notation
     * i.e. this.path('value.function[3].body')
     *
     * @param string pathString
     * @param any dummy result when ancestor is not found
     * @return CaptureNode/dummy
     */
    path: func(pathString, dummy = this.dummy) {

        var step;
        var current = this;

        pathString = pathString.split('.');

        for (var id in pathString) {
            step = pathString[id].split('[');

            if (step.length === 1) {
                current = current.get(step[0]);
            } else {
                current = current.get(step[0], parseInt(step[1].slice(0, -1)));
            }

            if (current.isDummy()) {
                return dummy;
            }
        }

        return current;
    },

    /**
     * creates and adds a node of given subclass to this node
     *
     * @param string? key node key
     * @param string? value node value
     * @param Type node_type type of the newly created and added node. must be subtype of StringNode
     * @return StringNode the newly created StringNode
     */
    addNew: func(key, value, Type) {

        var child = new Type(key, value);

        assert(child != null);

        child.parent = this;

        return this.add(child);
    },

    /**
      * extracts a set of this node's children and returns them
      *
      * @param from start inclusive child index
      * @param to end inclusive child index
      */
    extract: func(from, to) {

        return this.children.splice(from, to - from + 1);
    },

    /**
      * moves a set of this node's children into a single child node and places it where the set used to be
      *
      * @param from inclusive start child index
      * @param to inclusive end child index
      * @param Constructor optional constructor for the new node, defaults to parent type
      */
    nest: func(from, to, Constructor = this.constructor) {

        var node = new Constructor(this.key, this.value);

        node.children = this.children.splice(from, to - from + 1, node);
        node.parent = this;
        node.tpl = this.tpl;
        node.row = node.children[0].row;
        node.col = node.children[0].col;

        for (var id, child in node.children) {
            child.parent = node;
        }
    },

    /**
     * returns a newline and optionally increases or decreases indentation for the following lines
     *
     * @param indent change in indentation
     */
    nl: func(indent) {

        indent = (indent === undefined ? 0 : indent);

        var parser = this.parser();
        parser.indent += indent;
        return '\n' + String.repeat(parser.indent * 4, ' ');
    },

    /**
     * creates and returns a new sourcenode based on CaptureNode's position and given code
     *
     * @param code
     */
    csn: func(code) {

        return new SourceNode(this.row, this.col -1, this.parser().file, code); //!todo why is everthing offset by one if I don't subtract 1 here? col start at 0, row at 1? unlikely
    },

    /**
     * default node to string handler, returns empty string but calls children recursively
     *
     * @return string
     */
    toString: func() {

        var result = '';

        if (this.children instanceof Array) {
            for (var id in this.children) {
                result += this.children[id].toString();
            }
        }

        return result;
    },

    /**
     * default node to source-node handler, returns empty node but calls children recursively
     *
     * @return string
     */
    toSourceNode: func() {

        var result = new SourceNode(null, null);

        if (this.children instanceof Array) {
            for (var id in this.children) {
                result.add(this.children[id].toSourceNode());
            }
        }

        return result;
    },

    /**
     * recursively calls children for scanning purposes
     *
     * @param state userdefined scan state object passed to every child
     */
    scan: func(state) {

        if (this.children instanceof Array) {
            for (var id, child in this.children) {
                child.scan(state);
            }
        }
    },

    /**
     * recursively calls children for preprocessing purposes
     *
     * @param state userdefined preprocessing state object passed to every child
     */
    preprocess: func(state) {

        if (this.children instanceof Array) {
            for (var id, child in this.children) {
                child.preprocess(state);
            }
        }
    },

    /**
     * iterate over all childnodes
     *
     * @param NodeCallback func(node, first, last)
     */
    each: func(fn) {

        var children = this.children;

        if (children instanceof Array) {

            var last = children.length -1;

            for (var id in children) {
                fn.call(this, children[id], +id === 0, +id === last);
            }
        }
    },

    /**
     * iterate over all childnodes with given key
     *
     * @param string key node key
     * @param NodeCallback func(node, first, last)
     */
    eachKey: func(key, fn) {

        var part = key.split('.');

        if (this.children instanceof Array) {

            var children = this.children;
            var len = children.length;
            var prevChild = null;
            var first = true;
            var id;

            for (id = 0; id < len; id++) {
                var child = children[id];

                if (child.key === part[0]) {
                    if (part.length === 1) {

                        // delay by one loop to be able to identify the last item

                        if (prevChild !== null) {
                            fn.call(this, prevChild, first, false);
                            first = false;
                        }

                        prevChild = child;

                    } else if (part.length > 1) {
                        child.eachKey(part.slice(1).join('.'), fn);
                    }
                }
            }

            // last item

            if (prevChild !== null && prevChild.key === part[0] && part.length === 1) {
                fn.call(this, prevChild, first, true);
            }
        }
    },

    /**
     * initialize a template object for this node and set the file to be used during tplGenerate()
     *
     * @param string fileName
     */
    setTemplate: func(fileName) {

        this.tpl = new Template();
        this.tpl.debug = this.parser().transform.options['debug'];
        this.tplFile = fileName;
    },

    /**
     * returns generated template string for previously selected template file and assigned values
     *
     * @return string generated template string
     */
    processTemplate: func() {

        assert(this.tpl instanceof Template);

        return this.tpl.fetchFile(this.tplFile);
    },

    /**
     * assigns a value to the current template
     *
     * @param string uri qualified variable name
     * @param any value
     */
    assign: func(uri, value) {

        this.tpl.assign(uri, value);
    },
};

/**
 * dummy returned by some functions as a convenience
 */
CaptureNode::dummy = new CaptureNode('', '');
CaptureNode::dummy.row = -1;
CaptureNode::dummy.col = -1;
