/*
 * Adria transcompiler
 *
 * Copyright (C) 2014 Dennis MÃ¶hlmann <mail@dennismoehlmann.de>
 * Licensed under the MIT license.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

var Async = require('async');

// ensure the test was compiled with assertions enabled

var thrown = null;

try {
    assert(false);
} catch (e) {
    thrown = e;
}

if (thrown === null) {
    console.log('assertion support is disabled, please recompile with --assert');
    process.exit(1);
}

if (thrown.stack.split(':', 1)[0] !== 'AssertionFailedException') {
    console.log('incorrect assertion type thrown during pretest, environment incompatible');
    process.exit(1);
}


// set up module

var testId, start, last, oks, fails, exceptions;

var inAsync = false;
var queue = [ ];

module test = func(name, testFunction) {

    queue.push({ name: name, test: testFunction });

    if (inAsync) {
        return;
    } else {
        nextItem();
    }
};

export summary = func() {

    queue.push({ summary: true });

    if (inAsync) {
        return;
    } else {
        nextItem();
    }
};

var asyncCallback = func(exception = null) {

    inAsync = false;

    if (exception !== null) {
        exceptions.push(exception);
        fails++;
        print('FAIL');
    } else {
        oks++;
        print('ok');
    }

    nextItem();
};

var nextItem = func() {

    while (queue.length > 0) {

        var item = queue.shift();

        if (item.test) {
            if (runTest(item)) {
                break;
            }
        } else if (item.summary) {
            showSummary();
        }
    }
};

var showSummary = func(item) {

    log((oks + fails) + ' tests done, ' + oks + ' ok, ' + fails + (fails > 0 ? ' FAILURES' : ' failures'));

    for (var id, exception in exceptions) {
        console.log('failure ' + (+id + 1), exception.stack);
    }
};

var runTest = func(item) {

    var success = true;
    var asyncObject = null;

    log('test ' + testId++ + ': ' + item.name + ' ', false);

    try {

        if ((asyncObject = item.test(asyncCallback)) instanceof Async) {

            // async test, exit here and wait for callback

            if (asyncObject.done !== true) {
                inAsync = true;
                return true;
            }
        }

    } catch (e) {

        // test failed, log exception

        success = false;
        exceptions.push(e);
        fails++;
        print('FAIL');
    }

    if (success) {
        oks++;
        print('ok');
    }

    return false;
};

export log = func(message, nl = true) {

    var now         = Date.now();
    var diffStart   = now - start;
    var diffLast    = now - last;

    last = now;

    process.stdout.write(('+' + diffLast + '/' + diffStart) + 'ms: ' + message + (nl ? '\n' : ''));
};

export print = func(message, nl = true) {

    process.stdout.write(message + (nl ? '\n' : ''));
};

export fail = func(message) {

    throw new Error(message);
};

export reset = func() {

    testId      = 1;
    start       = Date.now();
    last        = start;
    oks         = 0;
    fails       = 0;
    exceptions  = [ ];
};

// start timer

reset();