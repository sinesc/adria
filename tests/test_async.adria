/*
 * Adria transcompiler
 *
 * Copyright (C) 2014 Dennis MÃ¶hlmann <mail@dennismoehlmann.de>
 * Licensed under the MIT license.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var Async = require('async');
var test = require('./test');

// prepare some functions

var sleep = function(ms, callback) {
if (typeof callback !== 'function') {
    console.log('cb is', callback);
    debugger;
}
    setTimeout(function() {
        callback(null, ms);
    }, ms);
};

var sleepError = function(ms, callback) {
    setTimeout(function() {
        callback(new Error('expected error'), 'not returned');
    }, ms);
};

var sleepThrow = function() {
    throw new Error('expected error');
};

// tests

test('wrap, then await', func#(done) {

    var wrap = sleep(10, #);
    var result = await wrap;
    assert(result === 10);

    done();
});

test('await wrap', func#(done) {

    var result = await sleep(11, #);
    assert(result === 11);

    done();
});

test('wrap throwing', func#(done) {

    var wrap, thrown = false;

    try {
        wrap = await sleepThrow(10, #);
    } catch (e) {
        thrown = true;
        assert(e instanceof Error);
    }

    assert(thrown === true);

    done();
});

test('wrap, then yield', func#(done) {

    var wrap = sleep(10, #);
    var result = yield wrap;
    assert(result === 10);
    
    done();
});

test('yield wrap', func#(done) {

    var result = yield sleep(11, #);
    assert(result === 11);
    
    done();
});

test('wrap throwing, await it', func#(done) {

    var wrap, result, thrown;

    try {
         wrap = sleepThrow(10, #);
    } catch (e) {
        assert(false);
    }

    try {
        result = yield wrap;
    } catch (e) {
        thrown = e;
    }

    assert(thrown instanceof Error && thrown.message === 'expected error');
    
    done();
});

test('wrap error, await it', func#(done) {

    var wrap, result, thrown;

    try {
         wrap = sleepError(10, #);
    } catch (e) {
        assert('never reached');
    }

    try {
        result = yield wrap;
    } catch (e) {
        thrown = e;
    }

    assert(thrown instanceof Error && thrown.message === 'expected error');
    
    done();
});

test('wrap and yield multiple, array', func#(done) {

    var result = yield [
        sleep(15, #),
        sleep(5, #),
        sleep(10, #),
    ];

    assert(result instanceof Array && result[0] === 15 && result[1] === 5 && result[2] === 10);
    
    done();
});

test('wrap and yield multiple, object', func#(done) {

    var result = yield {
        a: sleep(15, #),
        b: sleep(5, #),
        c: sleep(10, #),
    };

    assert(result instanceof Object && result.a === 15 && result.b === 5 && result.c === 10);
    
    done();
});

test('wrap and yield multiple, single invalid argument', func#(done) {

    var result = undefined, thrown = undefined;

    try {
        result = yield [
            sleep(15, #),
            sleep(5, function() { }),       // not a wrap op
        ];
    } catch (e) {
        thrown = e;
    }

    assert(result === undefined && thrown instanceof Async.AsyncException);
    
    done();
});

test('wrap and yield multiple, single error', func#(done) {

    var result = undefined, thrown = undefined;

    try {
        result = yield [
            sleepError(10, #),
            sleep(15, #),
        ];
    } catch (e) {
        thrown = e;
    }

    assert(result === undefined && thrown instanceof Error && thrown.message === 'expected error');
    
    done();
});

test('wrap and yield multiple, all error', func#(done) {

    var result = undefined, thrown = undefined;

    try {
        result = yield [
            sleepError(10, #),
            sleepError(10, #),
        ];
    } catch (e) {
        thrown = e;
    }

    assert(result === undefined && thrown instanceof Error && thrown.message === 'expected error');
    
    done();
});

if (test.noSummary !== true) {
    test.summary();
}