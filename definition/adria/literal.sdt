
/*
 * object literal
 */

object_literal_item {
    entry -> name:key -> ":"
    entry -> string:key -> ":"
    ":" -> literal_expression:value -> return
}

object_literal {
    entry -> "{" -> "}" -> return
    "{" -> object_literal_item:item -> "}"
    object_literal_item:item -> ","[any] -> object_literal_item:item

    // allow comma behind last item

    object_literal_item:item -> ","[last] -> "}"
}

/*
 * property literal
 */

property_literal {
    entry -> "prop" -> property_accessor -> return
    entry -> "prop" -> property_data -> return
}

property_accessor {
    entry -> "{" -> property_accessor_item:item -> "}" -> return
    property_accessor_item:item -> ","[any] -> property_accessor_item:item
    property_accessor_item:item -> ","[last] -> "}" -> return
}

property_data {
    entry -> "{" -> property_data_item:item -> "}" -> return
    property_data_item:item -> ","[any] -> property_data_item:item
    property_data_item:item -> ","[last] -> "}" -> return
}

property_accessor_item {
    entry -> "inherit":inherit -> "get":key[inherited] -> return
    "inherit":inherit -> "set":key[inherited] -> return
    
    entry -> "default":key -> ":"
    entry -> "storage":key -> ":"[storage] -> string:value -> return
    entry -> "get":key -> ":"
    entry -> "set":key -> ":"
    entry -> "configurable":key -> ":"
    entry -> "enumerable":key -> ":"
    ":" -> literal_expression:value -> return
}

property_data_item {
    entry -> "value":key -> ":"
    entry -> "writable":key -> ":"
    entry -> "configurable":key -> ":"
    entry -> "enumerable":key -> ":"
    ":" -> literal_expression:value -> return
}

/*
 * array literal
 */

array_literal {
    entry -> "[" -> "]" -> return
    "[" -> literal_expression:item -> "]"
    literal_expression:item -> ","[any] -> literal_expression:item

    // allow comma behind last literal item

    literal_expression:item -> ","[last] -> "]"
}

/*
 * scope literal
 */
//!TBD
/*scope_literal {
    entry -> "scope" -> "{" -> block:body -> "}" -> return
}*/

/*
 * function literal
 */

async_literal {
    //entry -> "function" -> "#":async

    entry -> "func" -> "#":async -> "(" -> ")" -> block:body -> return
    "#":async -> ident:name -> "("
    "(" -> async_param_list:param_list -> ")"
}

generator_literal {
    //entry -> "function" -> "*":generator

    entry -> "func" -> "*":generator -> "(" -> ")" -> block:body -> return
    "*":generator -> ident:name -> "("
    "(" -> function_param_list:param_list -> ")"
}

function_literal {
    //entry -> "function" -> "("
    //"function" -> ident:name

    entry -> "func" -> "(" -> ")" -> block:body -> return
    "func" -> ident:name -> "("
    "(" -> function_param_list:param_list -> ")"
}

function_param {
    entry -> ident:annotation -> ident:name
    entry -> ident:name -> return
}

function_param_default {
    entry -> ident:annotation -> ident:name
    entry -> ident:name -> "=" -> expression:value -> return
}

function_param_list {

    // standard params:  a, b, c ....

    entry -> function_param:item -> return
    function_param:item -> ","[type_standard] -> function_param:item

    // defaulted params:  d = 1, e = 2, f = 3 ....

    entry -> function_param_default:item -> return
    function_param_default:item -> ","[type_defaulted] -> function_param_default:item

    // defaulted params following standard params:  a, b, c, d = 1, e = 2, f = 3
    // note: commas are named to prevent the defintion-parser from linking them and thus
    // creating a backlink from defaulted parameters to standard parameters

    function_param:item -> ","[one_way_bridge] -> function_param_default:item
}

async_param_list {

    //!todo cheapo solution for testing
    entry -> "#":callback -> function_param_list -> return
    entry -> function_param_list -> "#":callback -> return
    entry -> function_param_list -> return
}

/*
 * require literal
 */

require_literal {
    // this is really just a function, but it has to be evaluable at compilation time
    entry -> "require" -> "(" -> const_literal:file -> ")" -> return
}

/*
 * resource
 */

resource_literal {
    // this is really just a function, but it has to be evaluable at compilation time
    entry -> "resource" -> "(" -> const_literal:file -> ")" -> return
}

/*
 * generator/async yield
 */

yield_literal {
    entry -> "yield":type -> return
    "yield":type -> literal_expression:value -> return
}

await_literal {
    entry -> "await":type -> return
    "await":type -> literal_expression:value -> return
}

/*
 * interheritance
 */

parent_literal {
    entry -> "parent" -> return
}

self_literal {
    entry -> "self" -> return
}

/*
 * storage
 */

storage_literal {
    entry -> "storage" -> return
}

/*
 * literal groups
 */

const_literal {
    entry -> numeric:numeric -> return
    entry -> string:string -> return
    entry -> regexp:regexp -> return
}

base_literal {
    // usable in expressions
    entry -> const_literal -> return
    entry -> ident:ident -> return
    entry -> object_literal:object -> return
    entry -> array_literal:array -> return
    entry -> require_literal:require -> return
    entry -> resource_literal:resource -> return
    entry -> parent_literal:parent -> return
    entry -> self_literal:self -> return
    entry -> storage_literal:storage -> return
    entry -> yield_literal:yield -> return
    entry -> await_literal:await -> return
    entry -> "(":brace -> complex_literal -> ")":brace -> return
}

complex_literal {
    // not directly usable in expressions
    entry -> function_literal:function -> return
    entry -> proto_literal:proto -> return
    entry -> new_proto_literal:newproto -> return
    entry -> generator_literal:generator -> return
    entry -> async_literal:async -> return
}

literal {
    entry -> base_literal -> return
    entry -> complex_literal -> return
}